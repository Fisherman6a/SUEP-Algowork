[
     [
          {
               "algorithm": "\nThe new algorithm selects the next node by first calculating the distance of all unvisited nodes to the current node, then selecting the node with the shortest distance as the next node.\n",
               "code": "import numpy as np\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    distances = distance_matrix[current_node, unvisited_nodes]\n    next_node = unvisited_nodes[np.argmin(distances)]\n    return next_node",
               "objective": 7.21241,
               "other_inf": null
          },
          {
               "algorithm": "The algorithm selects the next node by considering a weighted score balancing the nearest distance from the current node and the nearest distance to the destination node among unvisited nodes.",
               "code": "import numpy as np\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    distances_from_current = distance_matrix[current_node, unvisited_nodes]\n    distances_to_destination = distance_matrix[unvisited_nodes, destination_node]\n    combined_scores = 0.7 * distances_from_current + 0.3 * distances_to_destination\n    next_node_index = np.argmin(combined_scores)\n    next_node = unvisited_nodes[next_node_index]\n    return next_node",
               "objective": 7.35261,
               "other_inf": [
                    "    distances_from_current = distance_matrix[current_node, unvisited_nodes]",
                    "    distances_to_destination = distance_matrix[unvisited_nodes, destination_node]",
                    "    combined_scores = 0.7 * distances_from_current + 0.3 * distances_to_destination",
                    "    next_node_index = np.argmin(combined_scores)",
                    "    next_node = unvisited_nodes[next_node_index]"
               ]
          }
     ],
     [
          {
               "algorithm": "The algorithm selects the next node by considering a weighted score balancing the nearest distance from the current node and the nearest distance to the destination node among unvisited nodes.",
               "code": "import numpy as np\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    distances_from_current = distance_matrix[current_node, unvisited_nodes]\n    distances_to_destination = distance_matrix[unvisited_nodes, destination_node]\n    combined_scores = 0.7 * distances_from_current + 0.3 * distances_to_destination\n    next_node_index = np.argmin(combined_scores)\n    next_node = unvisited_nodes[next_node_index]\n    return next_node",
               "objective": 7.35261,
               "other_inf": [
                    "    distances_from_current = distance_matrix[current_node, unvisited_nodes]",
                    "    distances_to_destination = distance_matrix[unvisited_nodes, destination_node]",
                    "    combined_scores = 0.7 * distances_from_current + 0.3 * distances_to_destination",
                    "    next_node_index = np.argmin(combined_scores)",
                    "    next_node = unvisited_nodes[next_node_index]"
               ]
          },
          {
               "algorithm": "The algorithm selects the next node by maximizing a weighted sum of proximity to the current node, centrality based on average distance to other unvisited nodes, and a penalty for distance from the destination.",
               "code": "import numpy as np\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if len(unvisited_nodes) == 0:\n        return destination_node\n    \n    sub_matrix = distance_matrix[np.ix_(unvisited_nodes, unvisited_nodes)]\n    centrality = np.mean(sub_matrix, axis=1)\n    norm_centrality = (centrality - centrality.min()) / (centrality.max() - centrality.min() + 1e-9)\n    \n    dist_from_current = distance_matrix[current_node, unvisited_nodes]\n    norm_dist_current = (dist_from_current - dist_from_current.min()) / (dist_from_current.max() - dist_from_current.min() + 1e-9)\n    \n    dist_to_dest = distance_matrix[unvisited_nodes, destination_node]\n    norm_dist_dest = (dist_to_dest - dist_to_dest.min()) / (dist_to_dest.max() - dist_to_dest.min() + 1e-9)\n    \n    combined_scores = 0.5 * norm_centrality - 0.4 * norm_dist_current - 0.1 * norm_dist_dest\n    \n    next_node_index = np.argmax(combined_scores)\n    next_node = unvisited_nodes[next_node_index]\n    return next_node",
               "objective": 7.75798,
               "other_inf": [
                    "    if len(unvisited_nodes) == 0:",
                    "        return destination_node",
                    "    sub_matrix = distance_matrix[np.ix_(unvisited_nodes, unvisited_nodes)]",
                    "    centrality = np.mean(sub_matrix, axis=1)",
                    "    norm_centrality = (centrality - centrality.min()) / (centrality.max() - centrality.min() + 1e-9)",
                    "    dist_from_current = distance_matrix[current_node, unvisited_nodes]",
                    "    norm_dist_current = (dist_from_current - dist_from_current.min()) / (dist_from_current.max() - dist_from_current.min() + 1e-9)",
                    "    dist_to_dest = distance_matrix[unvisited_nodes, destination_node]",
                    "    norm_dist_dest = (dist_to_dest - dist_to_dest.min()) / (dist_to_dest.max() - dist_to_dest.min() + 1e-9)",
                    "    combined_scores = 0.5 * norm_centrality - 0.4 * norm_dist_current - 0.1 * norm_dist_dest",
                    "    next_node_index = np.argmax(combined_scores)"
               ]
          }
     ],
     [
          {
               "algorithm": "The algorithm selects the next node by maximizing a weighted sum of proximity to the current node, centrality based on average distance to other unvisited nodes, and a penalty for distance from the destination.",
               "code": "import numpy as np\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if len(unvisited_nodes) == 0:\n        return destination_node\n    \n    sub_matrix = distance_matrix[np.ix_(unvisited_nodes, unvisited_nodes)]\n    centrality = np.mean(sub_matrix, axis=1)\n    norm_centrality = (centrality - centrality.min()) / (centrality.max() - centrality.min() + 1e-9)\n    \n    dist_from_current = distance_matrix[current_node, unvisited_nodes]\n    norm_dist_current = (dist_from_current - dist_from_current.min()) / (dist_from_current.max() - dist_from_current.min() + 1e-9)\n    \n    dist_to_dest = distance_matrix[unvisited_nodes, destination_node]\n    norm_dist_dest = (dist_to_dest - dist_to_dest.min()) / (dist_to_dest.max() - dist_to_dest.min() + 1e-9)\n    \n    combined_scores = 0.5 * norm_centrality - 0.4 * norm_dist_current - 0.1 * norm_dist_dest\n    \n    next_node_index = np.argmax(combined_scores)\n    next_node = unvisited_nodes[next_node_index]\n    return next_node",
               "objective": 7.75798,
               "other_inf": [
                    "    if len(unvisited_nodes) == 0:",
                    "        return destination_node",
                    "    sub_matrix = distance_matrix[np.ix_(unvisited_nodes, unvisited_nodes)]",
                    "    centrality = np.mean(sub_matrix, axis=1)",
                    "    norm_centrality = (centrality - centrality.min()) / (centrality.max() - centrality.min() + 1e-9)",
                    "    dist_from_current = distance_matrix[current_node, unvisited_nodes]",
                    "    norm_dist_current = (dist_from_current - dist_from_current.min()) / (dist_from_current.max() - dist_from_current.min() + 1e-9)",
                    "    dist_to_dest = distance_matrix[unvisited_nodes, destination_node]",
                    "    norm_dist_dest = (dist_to_dest - dist_to_dest.min()) / (dist_to_dest.max() - dist_to_dest.min() + 1e-9)",
                    "    combined_scores = 0.5 * norm_centrality - 0.4 * norm_dist_current - 0.1 * norm_dist_dest",
                    "    next_node_index = np.argmax(combined_scores)"
               ]
          },
          {
               "algorithm": "The algorithm selects the next node by balancing proximity to the current node, global centrality based on average distance to all unvisited nodes, a penalty for distance from the final destination, and a novelty factor that prioritizes nodes with low visit density in their spatial neighborhood.",
               "code": "import numpy as np\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if len(unvisited_nodes) == 0:\n        return destination_node\n    \n    dist_to_current = distance_matrix[current_node, unvisited_nodes]\n    norm_dist_current = (dist_to_current - dist_to_current.min()) / (dist_to_current.max() - dist_to_current.min() + 1e-9)\n    \n    centrality = np.mean(distance_matrix[np.ix_(unvisited_nodes, unvisited_nodes)], axis=1)\n    norm_centrality = (centrality - centrality.min()) / (centrality.max() - centrality.min() + 1e-9)\n    \n    dist_to_dest = distance_matrix[unvisited_nodes, destination_node]\n    norm_dist_dest = (dist_to_dest - dist_to_dest.min()) / (dist_to_dest.max() - dist_to_dest.min() + 1e-9)\n    \n    coords = np.random.rand(len(distance_matrix), 2)\n    local_density = np.zeros(len(unvisited_nodes))\n    for i, node in enumerate(unvisited_nodes):\n        radii = distance_matrix[node] <= np.percentile(distance_matrix[node], 25)\n        local_density[i] = np.sum(~np.isin(np.arange(len(distance_matrix)), unvisited_nodes) & radii)\n    norm_density = (local_density - local_density.min()) / (local_density.max() - local_density.min() + 1e-9)\n    \n    scores = 0.35 * (1 - norm_dist_current) + 0.25 * norm_centrality + 0.25 * (1 - norm_dist_dest) + 0.15 * (1 - norm_density)\n    next_node_index = np.argmax(scores)\n    next_node = unvisited_nodes[next_node_index]\n    return next_node",
               "objective": 7.63073,
               "other_inf": [
                    "    dist_to_current = distance_matrix[current_node, unvisited_nodes]",
                    "    norm_dist_current = (dist_to_current - dist_to_current.min()) / (dist_to_current.max() - dist_to_current.min() + 1e-9)",
                    "    centrality = np.mean(distance_matrix[np.ix_(unvisited_nodes, unvisited_nodes)], axis=1)",
                    "    coords = np.random.rand(len(distance_matrix), 2)",
                    "    local_density = np.zeros(len(unvisited_nodes))",
                    "    for i, node in enumerate(unvisited_nodes):",
                    "        radii = distance_matrix[node] <= np.percentile(distance_matrix[node], 25)",
                    "        local_density[i] = np.sum(~np.isin(np.arange(len(distance_matrix)), unvisited_nodes) & radii)",
                    "    norm_density = (local_density - local_density.min()) / (local_density.max() - local_density.min() + 1e-9)",
                    "    scores = 0.35 * (1 - norm_dist_current) + 0.25 * norm_centrality + 0.25 * (1 - norm_dist_dest) + 0.15 * (1 - norm_density)",
                    "    next_node_index = np.argmax(scores)"
               ]
          }
     ],
     [
          {
               "algorithm": "The algorithm selects the next node by balancing proximity to the current node, global centrality based on average distance to all unvisited nodes, a penalty for distance from the final destination, and a novelty factor that prioritizes nodes with low visit density in their spatial neighborhood.",
               "code": "import numpy as np\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if len(unvisited_nodes) == 0:\n        return destination_node\n    \n    dist_to_current = distance_matrix[current_node, unvisited_nodes]\n    norm_dist_current = (dist_to_current - dist_to_current.min()) / (dist_to_current.max() - dist_to_current.min() + 1e-9)\n    \n    centrality = np.mean(distance_matrix[np.ix_(unvisited_nodes, unvisited_nodes)], axis=1)\n    norm_centrality = (centrality - centrality.min()) / (centrality.max() - centrality.min() + 1e-9)\n    \n    dist_to_dest = distance_matrix[unvisited_nodes, destination_node]\n    norm_dist_dest = (dist_to_dest - dist_to_dest.min()) / (dist_to_dest.max() - dist_to_dest.min() + 1e-9)\n    \n    coords = np.random.rand(len(distance_matrix), 2)\n    local_density = np.zeros(len(unvisited_nodes))\n    for i, node in enumerate(unvisited_nodes):\n        radii = distance_matrix[node] <= np.percentile(distance_matrix[node], 25)\n        local_density[i] = np.sum(~np.isin(np.arange(len(distance_matrix)), unvisited_nodes) & radii)\n    norm_density = (local_density - local_density.min()) / (local_density.max() - local_density.min() + 1e-9)\n    \n    scores = 0.35 * (1 - norm_dist_current) + 0.25 * norm_centrality + 0.25 * (1 - norm_dist_dest) + 0.15 * (1 - norm_density)\n    next_node_index = np.argmax(scores)\n    next_node = unvisited_nodes[next_node_index]\n    return next_node",
               "objective": 7.63073,
               "other_inf": [
                    "    dist_to_current = distance_matrix[current_node, unvisited_nodes]",
                    "    norm_dist_current = (dist_to_current - dist_to_current.min()) / (dist_to_current.max() - dist_to_current.min() + 1e-9)",
                    "    centrality = np.mean(distance_matrix[np.ix_(unvisited_nodes, unvisited_nodes)], axis=1)",
                    "    coords = np.random.rand(len(distance_matrix), 2)",
                    "    local_density = np.zeros(len(unvisited_nodes))",
                    "    for i, node in enumerate(unvisited_nodes):",
                    "        radii = distance_matrix[node] <= np.percentile(distance_matrix[node], 25)",
                    "        local_density[i] = np.sum(~np.isin(np.arange(len(distance_matrix)), unvisited_nodes) & radii)",
                    "    norm_density = (local_density - local_density.min()) / (local_density.max() - local_density.min() + 1e-9)",
                    "    scores = 0.35 * (1 - norm_dist_current) + 0.25 * norm_centrality + 0.25 * (1 - norm_dist_dest) + 0.15 * (1 - norm_density)",
                    "    next_node_index = np.argmax(scores)"
               ]
          },
          {
               "algorithm": null,
               "code": null,
               "objective": null,
               "other_inf": null
          }
     ],
     [
          {
               "algorithm": "The algorithm selects the next node by balancing proximity to the current node, global centrality based on average distance to all unvisited nodes, a penalty for distance from the final destination, and a novelty factor that prioritizes nodes with low visit density in their spatial neighborhood.",
               "code": "import numpy as np\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if len(unvisited_nodes) == 0:\n        return destination_node\n    \n    dist_to_current = distance_matrix[current_node, unvisited_nodes]\n    norm_dist_current = (dist_to_current - dist_to_current.min()) / (dist_to_current.max() - dist_to_current.min() + 1e-9)\n    \n    centrality = np.mean(distance_matrix[np.ix_(unvisited_nodes, unvisited_nodes)], axis=1)\n    norm_centrality = (centrality - centrality.min()) / (centrality.max() - centrality.min() + 1e-9)\n    \n    dist_to_dest = distance_matrix[unvisited_nodes, destination_node]\n    norm_dist_dest = (dist_to_dest - dist_to_dest.min()) / (dist_to_dest.max() - dist_to_dest.min() + 1e-9)\n    \n    coords = np.random.rand(len(distance_matrix), 2)\n    local_density = np.zeros(len(unvisited_nodes))\n    for i, node in enumerate(unvisited_nodes):\n        radii = distance_matrix[node] <= np.percentile(distance_matrix[node], 25)\n        local_density[i] = np.sum(~np.isin(np.arange(len(distance_matrix)), unvisited_nodes) & radii)\n    norm_density = (local_density - local_density.min()) / (local_density.max() - local_density.min() + 1e-9)\n    \n    scores = 0.35 * (1 - norm_dist_current) + 0.25 * norm_centrality + 0.25 * (1 - norm_dist_dest) + 0.15 * (1 - norm_density)\n    next_node_index = np.argmax(scores)\n    next_node = unvisited_nodes[next_node_index]\n    return next_node",
               "objective": 7.63073,
               "other_inf": [
                    "    dist_to_current = distance_matrix[current_node, unvisited_nodes]",
                    "    norm_dist_current = (dist_to_current - dist_to_current.min()) / (dist_to_current.max() - dist_to_current.min() + 1e-9)",
                    "    centrality = np.mean(distance_matrix[np.ix_(unvisited_nodes, unvisited_nodes)], axis=1)",
                    "    coords = np.random.rand(len(distance_matrix), 2)",
                    "    local_density = np.zeros(len(unvisited_nodes))",
                    "    for i, node in enumerate(unvisited_nodes):",
                    "        radii = distance_matrix[node] <= np.percentile(distance_matrix[node], 25)",
                    "        local_density[i] = np.sum(~np.isin(np.arange(len(distance_matrix)), unvisited_nodes) & radii)",
                    "    norm_density = (local_density - local_density.min()) / (local_density.max() - local_density.min() + 1e-9)",
                    "    scores = 0.35 * (1 - norm_dist_current) + 0.25 * norm_centrality + 0.25 * (1 - norm_dist_dest) + 0.15 * (1 - norm_density)",
                    "    next_node_index = np.argmax(scores)"
               ]
          },
          {
               "algorithm": "The novel algorithm selects the next node by combining dynamic weighted scores for proximity, remaining-degree centrality, destination alignment, and a spatial novelty encouraging exploration of sparse regions.",
               "code": "import numpy as np\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if len(unvisited_nodes) == 0:\n        return None\n\n    dist_current = distance_matrix[current_node, unvisited_nodes]\n    norm_dist_current = (dist_current - dist_current.min()) / (dist_current.max() - dist_current.min() + 1e-9)\n\n    dist_dest = distance_matrix[destination_node, unvisited_nodes]\n    norm_dist_dest = (dist_dest - dist_dest.min()) / (dist_dest.max() - dist_dest.min() + 1e-9)\n\n    centrality = np.mean(distance_matrix[np.ix_(unvisited_nodes, unvisited_nodes)], axis=1)\n    norm_centrality = (centrality - centrality.min()) / (centrality.max() - centrality.min() + 1e-9)\n\n    all_nodes = np.arange(len(distance_matrix))\n    visit_density = np.zeros(len(all_nodes))\n    for i, node in enumerate(all_nodes):\n        radius = np.percentile(distance_matrix[node], 25)\n        neighbors = distance_matrix[node] <= radius\n        visit_density[node] = np.sum(~np.isin(all_nodes[neighbors], unvisited_nodes))\n\n    density_vals = visit_density[unvisited_nodes]\n    norm_density = (density_vals - density_vals.min()) / (density_vals.max() - density_vals.min() + 1e-9)\n\n    scores = 0.35 * (1 - norm_dist_current) + 0.25 * norm_centrality + 0.25 * (1 - norm_dist_dest) + 0.15 * (1 - norm_density)\n\n    next_node_index = np.argmax(scores)\n    next_node = unvisited_nodes[next_node_index]\n    return next_node",
               "objective": 7.63073,
               "other_inf": [
                    "        return None",
                    "    dist_current = distance_matrix[current_node, unvisited_nodes]",
                    "    norm_dist_current = (dist_current - dist_current.min()) / (dist_current.max() - dist_current.min() + 1e-9)",
                    "    dist_dest = distance_matrix[destination_node, unvisited_nodes]",
                    "    norm_dist_dest = (dist_dest - dist_dest.min()) / (dist_dest.max() - dist_dest.min() + 1e-9)",
                    "    all_nodes = np.arange(len(distance_matrix))",
                    "    visit_density = np.zeros(len(all_nodes))",
                    "    for i, node in enumerate(all_nodes):",
                    "        radius = np.percentile(distance_matrix[node], 25)",
                    "        neighbors = distance_matrix[node] <= radius",
                    "        visit_density[node] = np.sum(~np.isin(all_nodes[neighbors], unvisited_nodes))",
                    "    density_vals = visit_density[unvisited_nodes]",
                    "    norm_density = (density_vals - density_vals.min()) / (density_vals.max() - density_vals.min() + 1e-9)"
               ]
          }
     ],
     [
          {
               "algorithm": "The novel algorithm selects the next node by combining dynamic weighted scores for proximity, remaining-degree centrality, destination alignment, and a spatial novelty encouraging exploration of sparse regions.",
               "code": "import numpy as np\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if len(unvisited_nodes) == 0:\n        return None\n\n    dist_current = distance_matrix[current_node, unvisited_nodes]\n    norm_dist_current = (dist_current - dist_current.min()) / (dist_current.max() - dist_current.min() + 1e-9)\n\n    dist_dest = distance_matrix[destination_node, unvisited_nodes]\n    norm_dist_dest = (dist_dest - dist_dest.min()) / (dist_dest.max() - dist_dest.min() + 1e-9)\n\n    centrality = np.mean(distance_matrix[np.ix_(unvisited_nodes, unvisited_nodes)], axis=1)\n    norm_centrality = (centrality - centrality.min()) / (centrality.max() - centrality.min() + 1e-9)\n\n    all_nodes = np.arange(len(distance_matrix))\n    visit_density = np.zeros(len(all_nodes))\n    for i, node in enumerate(all_nodes):\n        radius = np.percentile(distance_matrix[node], 25)\n        neighbors = distance_matrix[node] <= radius\n        visit_density[node] = np.sum(~np.isin(all_nodes[neighbors], unvisited_nodes))\n\n    density_vals = visit_density[unvisited_nodes]\n    norm_density = (density_vals - density_vals.min()) / (density_vals.max() - density_vals.min() + 1e-9)\n\n    scores = 0.35 * (1 - norm_dist_current) + 0.25 * norm_centrality + 0.25 * (1 - norm_dist_dest) + 0.15 * (1 - norm_density)\n\n    next_node_index = np.argmax(scores)\n    next_node = unvisited_nodes[next_node_index]\n    return next_node",
               "objective": 7.63073,
               "other_inf": [
                    "        return None",
                    "    dist_current = distance_matrix[current_node, unvisited_nodes]",
                    "    norm_dist_current = (dist_current - dist_current.min()) / (dist_current.max() - dist_current.min() + 1e-9)",
                    "    dist_dest = distance_matrix[destination_node, unvisited_nodes]",
                    "    norm_dist_dest = (dist_dest - dist_dest.min()) / (dist_dest.max() - dist_dest.min() + 1e-9)",
                    "    all_nodes = np.arange(len(distance_matrix))",
                    "    visit_density = np.zeros(len(all_nodes))",
                    "    for i, node in enumerate(all_nodes):",
                    "        radius = np.percentile(distance_matrix[node], 25)",
                    "        neighbors = distance_matrix[node] <= radius",
                    "        visit_density[node] = np.sum(~np.isin(all_nodes[neighbors], unvisited_nodes))",
                    "    density_vals = visit_density[unvisited_nodes]",
                    "    norm_density = (density_vals - density_vals.min()) / (density_vals.max() - density_vals.min() + 1e-9)"
               ]
          },
          {
               "algorithm": "The algorithm selects the next node based on a composite score balancing proximity, alignment to the final destination, local visit density, and a penalty for recently visited directions.",
               "code": "import numpy as np\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if len(unvisited_nodes) == 0:\n        return None\n    all_nodes = np.arange(distance_matrix.shape[0])\n    dist_current = distance_matrix[current_node, unvisited_nodes]\n    norm_dist_current = (dist_current - dist_current.min()) / (dist_current.max() - dist_current.min() + 1e-9)\n    dist_dest = distance_matrix[destination_node, unvisited_nodes]\n    norm_dist_dest = (dist_dest - dist_dest.min()) / (dist_dest.max() - dist_dest.min() + 1e-9)\n    remaining_centrality = np.sum(distance_matrix[unvisited_nodes][:, unvisited_nodes], axis=1)\n    norm_centrality = (remaining_centrality - remaining_centrality.min()) / (remaining_centrality.max() - remaining_centrality.min() + 1e-9)\n    visit_density = np.zeros(len(all_nodes))\n    for i, node in enumerate(all_nodes):\n        radius = np.percentile(distance_matrix[node], 25)\n        neighbors = distance_matrix[node] <= radius\n        visit_density[node] = np.sum(~np.isin(all_nodes[neighbors], unvisited_nodes))\n    density_vals = visit_density[unvisited_nodes]\n    norm_density = (density_vals - density_vals.min()) / (density_vals.max() - density_vals.min() + 1e-9)\n    if 'last_vector' not in select_next_node.__dict__:\n        select_next_node.last_vector = None\n    if select_next_node.last_vector is not None:\n        direction_vectors = np.array([distance_matrix[current_node, unvisited_nodes] / (dist_current + 1e-9)]) * np.sign(np.random.randn(len(unvisited_nodes), 2)).T\n        penalty = np.dot(direction_vectors.T, select_next_node.last_vector) if direction_vectors.size else 0\n        norm_penalty = (penalty - penalty.min()) / (penalty.max() - penalty.min() + 1e-9)\n    else:\n        norm_penalty = np.zeros(len(unvisited_nodes))\n    scores = 0.30 * (1 - norm_dist_current) + 0.20 * norm_centrality + 0.25 * (1 - norm_dist_dest) + 0.15 * (1 - norm_density) + 0.10 * norm_penalty\n    next_node_index = np.argmax(scores)\n    next_node = unvisited_nodes[next_node_index]\n    select_next_node.last_vector = np.random.randn(2)\n    return next_node",
               "objective": 9.58272,
               "other_inf": [
                    "    all_nodes = np.arange(distance_matrix.shape[0])",
                    "    remaining_centrality = np.sum(distance_matrix[unvisited_nodes][:, unvisited_nodes], axis=1)",
                    "    norm_centrality = (remaining_centrality - remaining_centrality.min()) / (remaining_centrality.max() - remaining_centrality.min() + 1e-9)",
                    "    if 'last_vector' not in select_next_node.__dict__:",
                    "        select_next_node.last_vector = None",
                    "    if select_next_node.last_vector is not None:",
                    "        direction_vectors = np.array([distance_matrix[current_node, unvisited_nodes] / (dist_current + 1e-9)]) * np.sign(np.random.randn(len(unvisited_nodes), 2)).T",
                    "        penalty = np.dot(direction_vectors.T, select_next_node.last_vector) if direction_vectors.size else 0",
                    "        norm_penalty = (penalty - penalty.min()) / (penalty.max() - penalty.min() + 1e-9)",
                    "    else:",
                    "        norm_penalty = np.zeros(len(unvisited_nodes))",
                    "    scores = 0.30 * (1 - norm_dist_current) + 0.20 * norm_centrality + 0.25 * (1 - norm_dist_dest) + 0.15 * (1 - norm_density) + 0.10 * norm_penalty",
                    "    select_next_node.last_vector = np.random.randn(2)"
               ]
          }
     ],
     [
          {
               "algorithm": "The novel algorithm selects the next node by combining dynamic weighted scores for proximity, remaining-degree centrality, destination alignment, and a spatial novelty encouraging exploration of sparse regions.",
               "code": "import numpy as np\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if len(unvisited_nodes) == 0:\n        return None\n\n    dist_current = distance_matrix[current_node, unvisited_nodes]\n    norm_dist_current = (dist_current - dist_current.min()) / (dist_current.max() - dist_current.min() + 1e-9)\n\n    dist_dest = distance_matrix[destination_node, unvisited_nodes]\n    norm_dist_dest = (dist_dest - dist_dest.min()) / (dist_dest.max() - dist_dest.min() + 1e-9)\n\n    centrality = np.mean(distance_matrix[np.ix_(unvisited_nodes, unvisited_nodes)], axis=1)\n    norm_centrality = (centrality - centrality.min()) / (centrality.max() - centrality.min() + 1e-9)\n\n    all_nodes = np.arange(len(distance_matrix))\n    visit_density = np.zeros(len(all_nodes))\n    for i, node in enumerate(all_nodes):\n        radius = np.percentile(distance_matrix[node], 25)\n        neighbors = distance_matrix[node] <= radius\n        visit_density[node] = np.sum(~np.isin(all_nodes[neighbors], unvisited_nodes))\n\n    density_vals = visit_density[unvisited_nodes]\n    norm_density = (density_vals - density_vals.min()) / (density_vals.max() - density_vals.min() + 1e-9)\n\n    scores = 0.35 * (1 - norm_dist_current) + 0.25 * norm_centrality + 0.25 * (1 - norm_dist_dest) + 0.15 * (1 - norm_density)\n\n    next_node_index = np.argmax(scores)\n    next_node = unvisited_nodes[next_node_index]\n    return next_node",
               "objective": 7.63073,
               "other_inf": [
                    "        return None",
                    "    dist_current = distance_matrix[current_node, unvisited_nodes]",
                    "    norm_dist_current = (dist_current - dist_current.min()) / (dist_current.max() - dist_current.min() + 1e-9)",
                    "    dist_dest = distance_matrix[destination_node, unvisited_nodes]",
                    "    norm_dist_dest = (dist_dest - dist_dest.min()) / (dist_dest.max() - dist_dest.min() + 1e-9)",
                    "    all_nodes = np.arange(len(distance_matrix))",
                    "    visit_density = np.zeros(len(all_nodes))",
                    "    for i, node in enumerate(all_nodes):",
                    "        radius = np.percentile(distance_matrix[node], 25)",
                    "        neighbors = distance_matrix[node] <= radius",
                    "        visit_density[node] = np.sum(~np.isin(all_nodes[neighbors], unvisited_nodes))",
                    "    density_vals = visit_density[unvisited_nodes]",
                    "    norm_density = (density_vals - density_vals.min()) / (density_vals.max() - density_vals.min() + 1e-9)"
               ]
          },
          {
               "algorithm": "The algorithm selects the next node using a weighted composite score balancing greedy proximity, alignment towards the final destination, remaining degree centrality, and regional visit density to encourage exploration.",
               "code": "import numpy as np\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if len(unvisited_nodes) == 0:\n        return None\n    all_nodes = np.arange(distance_matrix.shape[0])\n    dist_current = distance_matrix[current_node, unvisited_nodes]\n    norm_dist_current = (dist_current - dist_current.min()) / (dist_current.max() - dist_current.min() + 1e-9)\n    dist_dest = distance_matrix[destination_node, unvisited_nodes]\n    norm_dist_dest = (dist_dest - dist_dest.min()) / (dist_dest.max() - dist_dest.min() + 1e-9)\n    centrality = np.sum(distance_matrix[unvisited_nodes][:, unvisited_nodes] < np.median(distance_matrix), axis=1)\n    norm_centrality = (centrality - centrality.min()) / (centrality.max() - centrality.min() + 1e-9)\n    visit_density = np.zeros(len(all_nodes))\n    for i, node in enumerate(all_nodes):\n        radius = np.percentile(distance_matrix[node], 25)\n        neighbors = np.where(distance_matrix[node] <= radius)[0]\n        visit_density[node] = np.sum(~np.isin(all_nodes[neighbors], unvisited_nodes))\n    density_vals = visit_density[unvisited_nodes]\n    norm_density = (density_vals - density_vals.min()) / (density_vals.max() - density_vals.min() + 1e-9)\n    weights = np.array([-0.4, -0.3, 0.2, -0.1])\n    scores = np.column_stack([norm_dist_current, norm_dist_dest, norm_centrality, norm_density]).dot(weights)\n    next_node_index = np.argmax(scores)\n    next_node = unvisited_nodes[next_node_index]\n    return next_node",
               "objective": 10.75547,
               "other_inf": [
                    "    all_nodes = np.arange(distance_matrix.shape[0])",
                    "    centrality = np.sum(distance_matrix[unvisited_nodes][:, unvisited_nodes] < np.median(distance_matrix), axis=1)",
                    "        neighbors = np.where(distance_matrix[node] <= radius)[0]",
                    "    weights = np.array([-0.4, -0.3, 0.2, -0.1])",
                    "    scores = np.column_stack([norm_dist_current, norm_dist_dest, norm_centrality, norm_density]).dot(weights)"
               ]
          }
     ],
     [
          {
               "algorithm": "The novel algorithm selects the next node by combining dynamic weighted scores for proximity, remaining-degree centrality, destination alignment, and a spatial novelty encouraging exploration of sparse regions.",
               "code": "import numpy as np\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if len(unvisited_nodes) == 0:\n        return None\n\n    dist_current = distance_matrix[current_node, unvisited_nodes]\n    norm_dist_current = (dist_current - dist_current.min()) / (dist_current.max() - dist_current.min() + 1e-9)\n\n    dist_dest = distance_matrix[destination_node, unvisited_nodes]\n    norm_dist_dest = (dist_dest - dist_dest.min()) / (dist_dest.max() - dist_dest.min() + 1e-9)\n\n    centrality = np.mean(distance_matrix[np.ix_(unvisited_nodes, unvisited_nodes)], axis=1)\n    norm_centrality = (centrality - centrality.min()) / (centrality.max() - centrality.min() + 1e-9)\n\n    all_nodes = np.arange(len(distance_matrix))\n    visit_density = np.zeros(len(all_nodes))\n    for i, node in enumerate(all_nodes):\n        radius = np.percentile(distance_matrix[node], 25)\n        neighbors = distance_matrix[node] <= radius\n        visit_density[node] = np.sum(~np.isin(all_nodes[neighbors], unvisited_nodes))\n\n    density_vals = visit_density[unvisited_nodes]\n    norm_density = (density_vals - density_vals.min()) / (density_vals.max() - density_vals.min() + 1e-9)\n\n    scores = 0.35 * (1 - norm_dist_current) + 0.25 * norm_centrality + 0.25 * (1 - norm_dist_dest) + 0.15 * (1 - norm_density)\n\n    next_node_index = np.argmax(scores)\n    next_node = unvisited_nodes[next_node_index]\n    return next_node",
               "objective": 7.63073,
               "other_inf": [
                    "        return None",
                    "    dist_current = distance_matrix[current_node, unvisited_nodes]",
                    "    norm_dist_current = (dist_current - dist_current.min()) / (dist_current.max() - dist_current.min() + 1e-9)",
                    "    dist_dest = distance_matrix[destination_node, unvisited_nodes]",
                    "    norm_dist_dest = (dist_dest - dist_dest.min()) / (dist_dest.max() - dist_dest.min() + 1e-9)",
                    "    all_nodes = np.arange(len(distance_matrix))",
                    "    visit_density = np.zeros(len(all_nodes))",
                    "    for i, node in enumerate(all_nodes):",
                    "        radius = np.percentile(distance_matrix[node], 25)",
                    "        neighbors = distance_matrix[node] <= radius",
                    "        visit_density[node] = np.sum(~np.isin(all_nodes[neighbors], unvisited_nodes))",
                    "    density_vals = visit_density[unvisited_nodes]",
                    "    norm_density = (density_vals - density_vals.min()) / (density_vals.max() - density_vals.min() + 1e-9)"
               ]
          },
          {
               "algorithm": "The algorithm selects the next node by combining weighted scores for proximity, remaining-degree centrality, destination alignment, and spatial novelty, then probabilistically samples based on a dynamically softened score distribution.",
               "code": "import numpy as np\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if len(unvisited_nodes) == 0:\n        return None\n\n    unvisited = np.array(unvisited_nodes)\n    dist_to_unvisited = distance_matrix[current_node, unvisited]\n    norm_proximity = (dist_to_unvisited.max() - dist_to_unvisited) / (dist_to_unvisited.max() - dist_to_unvisited.min() + 1e-9)\n\n    deg_centrality = np.zeros(len(unvisited))\n    for idx, node in enumerate(unvisited):\n        radius = np.percentile(distance_matrix[node], 25)\n        neighbors = distance_matrix[node] <= radius\n        deg_centrality[idx] = np.sum(neighbors) - 1\n    norm_centrality = (deg_centrality - deg_centrality.min()) / (deg_centrality.max() - deg_centrality.min() + 1e-9)\n\n    dist_to_dest = distance_matrix[unvisited, destination_node]\n    norm_dest = (dist_to_dest.max() - dist_to_dest) / (dist_to_dest.max() - dist_to_dest.min() + 1e-9)\n\n    visit_density = np.zeros(len(distance_matrix))\n    for i in range(len(distance_matrix)):\n        radius = np.percentile(distance_matrix[i], 10)\n        visit_density[i] = np.sum(distance_matrix[i] <= radius) - 1\n    density_vals = visit_density[unvisited]\n    norm_novelty = (density_vals.max() - density_vals) / (density_vals.max() - density_vals.min() + 1e-9)\n\n    weights = np.array([0.35, 0.25, 0.2, 0.2])\n    combined = weights[0] * norm_proximity + weights[1] * norm_centrality + weights[2] * norm_dest + weights[3] * norm_novelty\n    prob = np.exp(combined / 0.1) / np.sum(np.exp(combined / 0.1))\n    next_node = np.random.choice(unvisited, p=prob)\n    return next_node",
               "objective": 15.9727,
               "other_inf": [
                    "    unvisited = np.array(unvisited_nodes)",
                    "    dist_to_unvisited = distance_matrix[current_node, unvisited]",
                    "    norm_proximity = (dist_to_unvisited.max() - dist_to_unvisited) / (dist_to_unvisited.max() - dist_to_unvisited.min() + 1e-9)",
                    "    deg_centrality = np.zeros(len(unvisited))",
                    "    for idx, node in enumerate(unvisited):",
                    "        deg_centrality[idx] = np.sum(neighbors) - 1",
                    "    norm_centrality = (deg_centrality - deg_centrality.min()) / (deg_centrality.max() - deg_centrality.min() + 1e-9)",
                    "    dist_to_dest = distance_matrix[unvisited, destination_node]",
                    "    norm_dest = (dist_to_dest.max() - dist_to_dest) / (dist_to_dest.max() - dist_to_dest.min() + 1e-9)",
                    "    visit_density = np.zeros(len(distance_matrix))",
                    "    for i in range(len(distance_matrix)):",
                    "        radius = np.percentile(distance_matrix[i], 10)",
                    "        visit_density[i] = np.sum(distance_matrix[i] <= radius) - 1",
                    "    density_vals = visit_density[unvisited]",
                    "    norm_novelty = (density_vals.max() - density_vals) / (density_vals.max() - density_vals.min() + 1e-9)",
                    "    weights = np.array([0.35, 0.25, 0.2, 0.2])",
                    "    combined = weights[0] * norm_proximity + weights[1] * norm_centrality + weights[2] * norm_dest + weights[3] * norm_novelty",
                    "    prob = np.exp(combined / 0.1) / np.sum(np.exp(combined / 0.1))",
                    "    next_node = np.random.choice(unvisited, p=prob)"
               ]
          }
     ],
     [
          {
               "algorithm": "The novel algorithm selects the next node by combining dynamic weighted scores for proximity, remaining-degree centrality, destination alignment, and a spatial novelty encouraging exploration of sparse regions.",
               "code": "import numpy as np\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if len(unvisited_nodes) == 0:\n        return None\n\n    dist_current = distance_matrix[current_node, unvisited_nodes]\n    norm_dist_current = (dist_current - dist_current.min()) / (dist_current.max() - dist_current.min() + 1e-9)\n\n    dist_dest = distance_matrix[destination_node, unvisited_nodes]\n    norm_dist_dest = (dist_dest - dist_dest.min()) / (dist_dest.max() - dist_dest.min() + 1e-9)\n\n    centrality = np.mean(distance_matrix[np.ix_(unvisited_nodes, unvisited_nodes)], axis=1)\n    norm_centrality = (centrality - centrality.min()) / (centrality.max() - centrality.min() + 1e-9)\n\n    all_nodes = np.arange(len(distance_matrix))\n    visit_density = np.zeros(len(all_nodes))\n    for i, node in enumerate(all_nodes):\n        radius = np.percentile(distance_matrix[node], 25)\n        neighbors = distance_matrix[node] <= radius\n        visit_density[node] = np.sum(~np.isin(all_nodes[neighbors], unvisited_nodes))\n\n    density_vals = visit_density[unvisited_nodes]\n    norm_density = (density_vals - density_vals.min()) / (density_vals.max() - density_vals.min() + 1e-9)\n\n    scores = 0.35 * (1 - norm_dist_current) + 0.25 * norm_centrality + 0.25 * (1 - norm_dist_dest) + 0.15 * (1 - norm_density)\n\n    next_node_index = np.argmax(scores)\n    next_node = unvisited_nodes[next_node_index]\n    return next_node",
               "objective": 7.63073,
               "other_inf": [
                    "        return None",
                    "    dist_current = distance_matrix[current_node, unvisited_nodes]",
                    "    norm_dist_current = (dist_current - dist_current.min()) / (dist_current.max() - dist_current.min() + 1e-9)",
                    "    dist_dest = distance_matrix[destination_node, unvisited_nodes]",
                    "    norm_dist_dest = (dist_dest - dist_dest.min()) / (dist_dest.max() - dist_dest.min() + 1e-9)",
                    "    all_nodes = np.arange(len(distance_matrix))",
                    "    visit_density = np.zeros(len(all_nodes))",
                    "    for i, node in enumerate(all_nodes):",
                    "        radius = np.percentile(distance_matrix[node], 25)",
                    "        neighbors = distance_matrix[node] <= radius",
                    "        visit_density[node] = np.sum(~np.isin(all_nodes[neighbors], unvisited_nodes))",
                    "    density_vals = visit_density[unvisited_nodes]",
                    "    norm_density = (density_vals - density_vals.min()) / (density_vals.max() - density_vals.min() + 1e-9)"
               ]
          },
          {
               "algorithm": "The algorithm selects the next node by combining exponentially decaying proximity, dynamic spatial entropy-based exploration, remaining node utility, and alignment toward the final destination, using adaptive weighting that shifts from exploration to exploitation as the tour progresses.",
               "code": "import numpy as np\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if len(unvisited_nodes) == 1:\n        return unvisited_nodes[0]\n    \n    n_unvisited = len(unvisited_nodes)\n    progress = 1 - (n_unvisited / (distance_matrix.shape[0] - 1))\n    \n    dist_to_unvisited = distance_matrix[current_node, unvisited_nodes]\n    proximity = 1 / (dist_to_unvisited + 1e-9)\n    \n    entropy_weights = np.zeros(n_unvisited)\n    for idx, node in enumerate(unvisited_nodes):\n        dist_to_others = distance_matrix[node, np.setdiff1d(unvisited_nodes, node)]\n        if len(dist_to_others) > 0:\n            hist, _ = np.histogram(dist_to_others, bins=5)\n            probs = hist / len(dist_to_others) + 1e-9\n            entropy = -np.sum(probs * np.log(probs))\n            entropy_weights[idx] = entropy\n    entropy_weights = (entropy_weights - entropy_weights.min()) / (entropy_weights.max() - entropy_weights.min() + 1e-9)\n    \n    remaining_utility = np.mean(distance_matrix[np.ix_(unvisited_nodes, unvisited_nodes)], axis=1)\n    remaining_utility = (remaining_utility - remaining_utility.min()) / (remaining_utility.max() - remaining_utility.min() + 1e-9)\n    \n    if destination_node in unvisited_nodes:\n        dest_alignment = (distance_matrix[destination_node, unvisited_nodes] - distance_matrix[destination_node, unvisited_nodes].min()) / (distance_matrix[destination_node, unvisited_nodes].max() - distance_matrix[destination_node, unvisited_nodes].min() + 1e-9)\n        dest_alignment = 1 - dest_alignment\n    else:\n        dest_alignment = np.ones(n_unvisited)\n    \n    w_prox = 0.5 - 0.3 * progress\n    w_entropy = 0.2 + 0.2 * progress\n    w_utility = 0.2\n    w_dest = 0.1 + 0.1 * progress\n    \n    scores = w_prox * proximity + w_entropy * entropy_weights + w_utility * remaining_utility + w_dest * dest_alignment\n    next_node_index = np.argmax(scores)\n    next_node = unvisited_nodes[next_node_index]\n    return next_node",
               "objective": 7.1031,
               "other_inf": [
                    "    if len(unvisited_nodes) == 1:",
                    "        return unvisited_nodes[0]",
                    "    n_unvisited = len(unvisited_nodes)",
                    "    progress = 1 - (n_unvisited / (distance_matrix.shape[0] - 1))",
                    "    dist_to_unvisited = distance_matrix[current_node, unvisited_nodes]",
                    "    proximity = 1 / (dist_to_unvisited + 1e-9)",
                    "    entropy_weights = np.zeros(n_unvisited)",
                    "    for idx, node in enumerate(unvisited_nodes):",
                    "        dist_to_others = distance_matrix[node, np.setdiff1d(unvisited_nodes, node)]",
                    "        if len(dist_to_others) > 0:",
                    "            hist, _ = np.histogram(dist_to_others, bins=5)",
                    "            probs = hist / len(dist_to_others) + 1e-9",
                    "            entropy = -np.sum(probs * np.log(probs))",
                    "            entropy_weights[idx] = entropy",
                    "    entropy_weights = (entropy_weights - entropy_weights.min()) / (entropy_weights.max() - entropy_weights.min() + 1e-9)",
                    "    remaining_utility = np.mean(distance_matrix[np.ix_(unvisited_nodes, unvisited_nodes)], axis=1)",
                    "    remaining_utility = (remaining_utility - remaining_utility.min()) / (remaining_utility.max() - remaining_utility.min() + 1e-9)",
                    "    if destination_node in unvisited_nodes:",
                    "        dest_alignment = (distance_matrix[destination_node, unvisited_nodes] - distance_matrix[destination_node, unvisited_nodes].min()) / (distance_matrix[destination_node, unvisited_nodes].max() - distance_matrix[destination_node, unvisited_nodes].min() + 1e-9)",
                    "        dest_alignment = 1 - dest_alignment",
                    "    else:",
                    "        dest_alignment = np.ones(n_unvisited)",
                    "    w_prox = 0.5 - 0.3 * progress",
                    "    w_entropy = 0.2 + 0.2 * progress",
                    "    w_utility = 0.2",
                    "    w_dest = 0.1 + 0.1 * progress",
                    "    scores = w_prox * proximity + w_entropy * entropy_weights + w_utility * remaining_utility + w_dest * dest_alignment"
               ]
          }
     ],
     [
          {
               "algorithm": "The algorithm selects the next node by combining exponentially decaying proximity, dynamic spatial entropy-based exploration, remaining node utility, and alignment toward the final destination, using adaptive weighting that shifts from exploration to exploitation as the tour progresses.",
               "code": "import numpy as np\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if len(unvisited_nodes) == 1:\n        return unvisited_nodes[0]\n    \n    n_unvisited = len(unvisited_nodes)\n    progress = 1 - (n_unvisited / (distance_matrix.shape[0] - 1))\n    \n    dist_to_unvisited = distance_matrix[current_node, unvisited_nodes]\n    proximity = 1 / (dist_to_unvisited + 1e-9)\n    \n    entropy_weights = np.zeros(n_unvisited)\n    for idx, node in enumerate(unvisited_nodes):\n        dist_to_others = distance_matrix[node, np.setdiff1d(unvisited_nodes, node)]\n        if len(dist_to_others) > 0:\n            hist, _ = np.histogram(dist_to_others, bins=5)\n            probs = hist / len(dist_to_others) + 1e-9\n            entropy = -np.sum(probs * np.log(probs))\n            entropy_weights[idx] = entropy\n    entropy_weights = (entropy_weights - entropy_weights.min()) / (entropy_weights.max() - entropy_weights.min() + 1e-9)\n    \n    remaining_utility = np.mean(distance_matrix[np.ix_(unvisited_nodes, unvisited_nodes)], axis=1)\n    remaining_utility = (remaining_utility - remaining_utility.min()) / (remaining_utility.max() - remaining_utility.min() + 1e-9)\n    \n    if destination_node in unvisited_nodes:\n        dest_alignment = (distance_matrix[destination_node, unvisited_nodes] - distance_matrix[destination_node, unvisited_nodes].min()) / (distance_matrix[destination_node, unvisited_nodes].max() - distance_matrix[destination_node, unvisited_nodes].min() + 1e-9)\n        dest_alignment = 1 - dest_alignment\n    else:\n        dest_alignment = np.ones(n_unvisited)\n    \n    w_prox = 0.5 - 0.3 * progress\n    w_entropy = 0.2 + 0.2 * progress\n    w_utility = 0.2\n    w_dest = 0.1 + 0.1 * progress\n    \n    scores = w_prox * proximity + w_entropy * entropy_weights + w_utility * remaining_utility + w_dest * dest_alignment\n    next_node_index = np.argmax(scores)\n    next_node = unvisited_nodes[next_node_index]\n    return next_node",
               "objective": 7.1031,
               "other_inf": [
                    "    if len(unvisited_nodes) == 1:",
                    "        return unvisited_nodes[0]",
                    "    n_unvisited = len(unvisited_nodes)",
                    "    progress = 1 - (n_unvisited / (distance_matrix.shape[0] - 1))",
                    "    dist_to_unvisited = distance_matrix[current_node, unvisited_nodes]",
                    "    proximity = 1 / (dist_to_unvisited + 1e-9)",
                    "    entropy_weights = np.zeros(n_unvisited)",
                    "    for idx, node in enumerate(unvisited_nodes):",
                    "        dist_to_others = distance_matrix[node, np.setdiff1d(unvisited_nodes, node)]",
                    "        if len(dist_to_others) > 0:",
                    "            hist, _ = np.histogram(dist_to_others, bins=5)",
                    "            probs = hist / len(dist_to_others) + 1e-9",
                    "            entropy = -np.sum(probs * np.log(probs))",
                    "            entropy_weights[idx] = entropy",
                    "    entropy_weights = (entropy_weights - entropy_weights.min()) / (entropy_weights.max() - entropy_weights.min() + 1e-9)",
                    "    remaining_utility = np.mean(distance_matrix[np.ix_(unvisited_nodes, unvisited_nodes)], axis=1)",
                    "    remaining_utility = (remaining_utility - remaining_utility.min()) / (remaining_utility.max() - remaining_utility.min() + 1e-9)",
                    "    if destination_node in unvisited_nodes:",
                    "        dest_alignment = (distance_matrix[destination_node, unvisited_nodes] - distance_matrix[destination_node, unvisited_nodes].min()) / (distance_matrix[destination_node, unvisited_nodes].max() - distance_matrix[destination_node, unvisited_nodes].min() + 1e-9)",
                    "        dest_alignment = 1 - dest_alignment",
                    "    else:",
                    "        dest_alignment = np.ones(n_unvisited)",
                    "    w_prox = 0.5 - 0.3 * progress",
                    "    w_entropy = 0.2 + 0.2 * progress",
                    "    w_utility = 0.2",
                    "    w_dest = 0.1 + 0.1 * progress",
                    "    scores = w_prox * proximity + w_entropy * entropy_weights + w_utility * remaining_utility + w_dest * dest_alignment"
               ]
          },
          {
               "algorithm": "The algorithm selects the next node by combining adaptive gravitational attraction, angular momentum conservation simulating smooth turns, a time-varying exploration bonus for clustered regions, and a homing factor that intensifies as the tour nears completion.",
               "code": "import numpy as np\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if len(unvisited_nodes) == 1:\n        return unvisited_nodes[0]\n    \n    progress = 1 - (len(unvisited_nodes) / len(distance_matrix))\n    \n    distance_vector = distance_matrix[current_node, unvisited_nodes]\n    proximity = np.exp(-distance_vector / distance_vector.mean())\n    \n    angles = np.zeros(len(unvisited_nodes))\n    for i, node in enumerate(unvisited_nodes):\n        if progress > 0.1 and len(unvisited_nodes) > 2:\n            angle_vec = np.array([distance_matrix[current_node, node],\n                                  distance_matrix[node, destination_node]])\n            angles[i] = np.linalg.norm(angle_vec - angle_vec.mean())\n    angular_smoothness = 1 / (1 + angles)\n    \n    coord_clustering = np.zeros(len(unvisited_nodes))\n    for i, node in enumerate(unvisited_nodes):\n        avg_dist_to_others = np.mean([distance_matrix[node, other] for other in unvisited_nodes if other != node])\n        coord_clustering[i] = avg_dist_to_others\n    cluster_bonus = np.exp(-progress * (coord_clustering / coord_clustering.max()))\n    \n    dest_dist = distance_matrix[destination_node, unvisited_nodes]\n    homing_factor = np.exp(-progress * dest_dist / dest_dist.mean())\n    \n    w_grav = 0.4 - 0.2 * progress\n    w_angular = 0.25 + 0.1 * progress\n    w_cluster = 0.25 - 0.15 * progress\n    w_homing = 0.1 + 0.25 * progress\n    \n    scores = w_grav * proximity + w_angular * angular_smoothness + w_cluster * cluster_bonus + w_homing * homing_factor\n    next_node_index = np.argmax(scores)\n    next_node = unvisited_nodes[next_node_index]\n    return next_node",
               "objective": 9.17719,
               "other_inf": [
                    "    progress = 1 - (len(unvisited_nodes) / len(distance_matrix))",
                    "    distance_vector = distance_matrix[current_node, unvisited_nodes]",
                    "    proximity = np.exp(-distance_vector / distance_vector.mean())",
                    "    angles = np.zeros(len(unvisited_nodes))",
                    "    for i, node in enumerate(unvisited_nodes):",
                    "        if progress > 0.1 and len(unvisited_nodes) > 2:",
                    "            angle_vec = np.array([distance_matrix[current_node, node],",
                    "                                  distance_matrix[node, destination_node]])",
                    "            angles[i] = np.linalg.norm(angle_vec - angle_vec.mean())",
                    "    angular_smoothness = 1 / (1 + angles)",
                    "    coord_clustering = np.zeros(len(unvisited_nodes))",
                    "    for i, node in enumerate(unvisited_nodes):",
                    "        avg_dist_to_others = np.mean([distance_matrix[node, other] for other in unvisited_nodes if other != node])",
                    "        coord_clustering[i] = avg_dist_to_others",
                    "    cluster_bonus = np.exp(-progress * (coord_clustering / coord_clustering.max()))",
                    "    dest_dist = distance_matrix[destination_node, unvisited_nodes]",
                    "    homing_factor = np.exp(-progress * dest_dist / dest_dist.mean())",
                    "    w_grav = 0.4 - 0.2 * progress",
                    "    w_angular = 0.25 + 0.1 * progress",
                    "    w_cluster = 0.25 - 0.15 * progress",
                    "    w_homing = 0.1 + 0.25 * progress",
                    "    scores = w_grav * proximity + w_angular * angular_smoothness + w_cluster * cluster_bonus + w_homing * homing_factor"
               ]
          }
     ],
     [
          {
               "algorithm": "The algorithm selects the next node by combining exponentially decaying proximity, dynamic spatial entropy-based exploration, remaining node utility, and alignment toward the final destination, using adaptive weighting that shifts from exploration to exploitation as the tour progresses.",
               "code": "import numpy as np\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if len(unvisited_nodes) == 1:\n        return unvisited_nodes[0]\n    \n    n_unvisited = len(unvisited_nodes)\n    progress = 1 - (n_unvisited / (distance_matrix.shape[0] - 1))\n    \n    dist_to_unvisited = distance_matrix[current_node, unvisited_nodes]\n    proximity = 1 / (dist_to_unvisited + 1e-9)\n    \n    entropy_weights = np.zeros(n_unvisited)\n    for idx, node in enumerate(unvisited_nodes):\n        dist_to_others = distance_matrix[node, np.setdiff1d(unvisited_nodes, node)]\n        if len(dist_to_others) > 0:\n            hist, _ = np.histogram(dist_to_others, bins=5)\n            probs = hist / len(dist_to_others) + 1e-9\n            entropy = -np.sum(probs * np.log(probs))\n            entropy_weights[idx] = entropy\n    entropy_weights = (entropy_weights - entropy_weights.min()) / (entropy_weights.max() - entropy_weights.min() + 1e-9)\n    \n    remaining_utility = np.mean(distance_matrix[np.ix_(unvisited_nodes, unvisited_nodes)], axis=1)\n    remaining_utility = (remaining_utility - remaining_utility.min()) / (remaining_utility.max() - remaining_utility.min() + 1e-9)\n    \n    if destination_node in unvisited_nodes:\n        dest_alignment = (distance_matrix[destination_node, unvisited_nodes] - distance_matrix[destination_node, unvisited_nodes].min()) / (distance_matrix[destination_node, unvisited_nodes].max() - distance_matrix[destination_node, unvisited_nodes].min() + 1e-9)\n        dest_alignment = 1 - dest_alignment\n    else:\n        dest_alignment = np.ones(n_unvisited)\n    \n    w_prox = 0.5 - 0.3 * progress\n    w_entropy = 0.2 + 0.2 * progress\n    w_utility = 0.2\n    w_dest = 0.1 + 0.1 * progress\n    \n    scores = w_prox * proximity + w_entropy * entropy_weights + w_utility * remaining_utility + w_dest * dest_alignment\n    next_node_index = np.argmax(scores)\n    next_node = unvisited_nodes[next_node_index]\n    return next_node",
               "objective": 7.1031,
               "other_inf": [
                    "    if len(unvisited_nodes) == 1:",
                    "        return unvisited_nodes[0]",
                    "    n_unvisited = len(unvisited_nodes)",
                    "    progress = 1 - (n_unvisited / (distance_matrix.shape[0] - 1))",
                    "    dist_to_unvisited = distance_matrix[current_node, unvisited_nodes]",
                    "    proximity = 1 / (dist_to_unvisited + 1e-9)",
                    "    entropy_weights = np.zeros(n_unvisited)",
                    "    for idx, node in enumerate(unvisited_nodes):",
                    "        dist_to_others = distance_matrix[node, np.setdiff1d(unvisited_nodes, node)]",
                    "        if len(dist_to_others) > 0:",
                    "            hist, _ = np.histogram(dist_to_others, bins=5)",
                    "            probs = hist / len(dist_to_others) + 1e-9",
                    "            entropy = -np.sum(probs * np.log(probs))",
                    "            entropy_weights[idx] = entropy",
                    "    entropy_weights = (entropy_weights - entropy_weights.min()) / (entropy_weights.max() - entropy_weights.min() + 1e-9)",
                    "    remaining_utility = np.mean(distance_matrix[np.ix_(unvisited_nodes, unvisited_nodes)], axis=1)",
                    "    remaining_utility = (remaining_utility - remaining_utility.min()) / (remaining_utility.max() - remaining_utility.min() + 1e-9)",
                    "    if destination_node in unvisited_nodes:",
                    "        dest_alignment = (distance_matrix[destination_node, unvisited_nodes] - distance_matrix[destination_node, unvisited_nodes].min()) / (distance_matrix[destination_node, unvisited_nodes].max() - distance_matrix[destination_node, unvisited_nodes].min() + 1e-9)",
                    "        dest_alignment = 1 - dest_alignment",
                    "    else:",
                    "        dest_alignment = np.ones(n_unvisited)",
                    "    w_prox = 0.5 - 0.3 * progress",
                    "    w_entropy = 0.2 + 0.2 * progress",
                    "    w_utility = 0.2",
                    "    w_dest = 0.1 + 0.1 * progress",
                    "    scores = w_prox * proximity + w_entropy * entropy_weights + w_utility * remaining_utility + w_dest * dest_alignment"
               ]
          },
          {
               "algorithm": "A next node is chosen based on a balanced blend of directed progress toward the destination, constrained local clustering attraction, and a global repulsion term that discourages revisiting spatial neighborhoods.",
               "code": "import numpy as np\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if len(unvisited_nodes) == 1:\n        return unvisited_nodes[0]\n    n_unvisited = len(unvisited_nodes)\n    dist_to_unvisited = distance_matrix[current_node, unvisited_nodes]\n    proximity = 1 / (dist_to_unvisited + 1e-9)\n    cluster_scores = np.zeros(n_unvisited)\n    for idx, node in enumerate(unvisited_nodes):\n        others = np.setdiff1d(unvisited_nodes, node)\n        if len(others) > 0:\n            cluster_dists = distance_matrix[node, others]\n            avg_cluster_dist = np.mean(cluster_dists)\n            cluster_scores[idx] = 1 / (avg_cluster_dist + 1e-9)\n    dest_dist = distance_matrix[unvisited_nodes, destination_node]\n    dest_alignment = 1 / (dest_dist + 1e-9)\n    remaining = len(unvisited_nodes)\n    global_centroid = np.mean(np.argwhere(np.isin(np.arange(distance_matrix.shape[0]), unvisited_nodes)), axis=0)\n    repulsion = np.zeros(n_unvisited)\n    for idx, node in enumerate(unvisited_nodes):\n        node_pos = np.argwhere(np.arange(distance_matrix.shape[0]) == node)[0][0]\n        repulsion[idx] = np.linalg.norm(node_pos - global_centroid)\n    repulsion = 1 / (repulsion + 1e-9)\n    progress = 1 - (remaining / distance_matrix.shape[0])\n    w_prox = 0.4 - 0.2 * progress\n    w_cluster = 0.2\n    w_dest = 0.2 + 0.2 * progress\n    w_rep = 0.2 - 0.1 * progress\n    scores = w_prox * proximity + w_cluster * cluster_scores + w_dest * dest_alignment + w_rep * repulsion\n    next_idx = np.argmax(scores)\n    next_node = unvisited_nodes[next_idx]\n    return next_node",
               "objective": 9.6138,
               "other_inf": [
                    "    cluster_scores = np.zeros(n_unvisited)",
                    "        others = np.setdiff1d(unvisited_nodes, node)",
                    "        if len(others) > 0:",
                    "            cluster_dists = distance_matrix[node, others]",
                    "            avg_cluster_dist = np.mean(cluster_dists)",
                    "            cluster_scores[idx] = 1 / (avg_cluster_dist + 1e-9)",
                    "    dest_dist = distance_matrix[unvisited_nodes, destination_node]",
                    "    dest_alignment = 1 / (dest_dist + 1e-9)",
                    "    remaining = len(unvisited_nodes)",
                    "    global_centroid = np.mean(np.argwhere(np.isin(np.arange(distance_matrix.shape[0]), unvisited_nodes)), axis=0)",
                    "    repulsion = np.zeros(n_unvisited)",
                    "        node_pos = np.argwhere(np.arange(distance_matrix.shape[0]) == node)[0][0]",
                    "        repulsion[idx] = np.linalg.norm(node_pos - global_centroid)",
                    "    repulsion = 1 / (repulsion + 1e-9)",
                    "    progress = 1 - (remaining / distance_matrix.shape[0])",
                    "    w_prox = 0.4 - 0.2 * progress",
                    "    w_cluster = 0.2",
                    "    w_dest = 0.2 + 0.2 * progress",
                    "    w_rep = 0.2 - 0.1 * progress",
                    "    scores = w_prox * proximity + w_cluster * cluster_scores + w_dest * dest_alignment + w_rep * repulsion",
                    "    next_idx = np.argmax(scores)",
                    "    next_node = unvisited_nodes[next_idx]"
               ]
          }
     ],
     [
          {
               "algorithm": "The algorithm selects the next node by combining exponentially decaying proximity, dynamic spatial entropy-based exploration, remaining node utility, and alignment toward the final destination, using adaptive weighting that shifts from exploration to exploitation as the tour progresses.",
               "code": "import numpy as np\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if len(unvisited_nodes) == 1:\n        return unvisited_nodes[0]\n    \n    n_unvisited = len(unvisited_nodes)\n    progress = 1 - (n_unvisited / (distance_matrix.shape[0] - 1))\n    \n    dist_to_unvisited = distance_matrix[current_node, unvisited_nodes]\n    proximity = 1 / (dist_to_unvisited + 1e-9)\n    \n    entropy_weights = np.zeros(n_unvisited)\n    for idx, node in enumerate(unvisited_nodes):\n        dist_to_others = distance_matrix[node, np.setdiff1d(unvisited_nodes, node)]\n        if len(dist_to_others) > 0:\n            hist, _ = np.histogram(dist_to_others, bins=5)\n            probs = hist / len(dist_to_others) + 1e-9\n            entropy = -np.sum(probs * np.log(probs))\n            entropy_weights[idx] = entropy\n    entropy_weights = (entropy_weights - entropy_weights.min()) / (entropy_weights.max() - entropy_weights.min() + 1e-9)\n    \n    remaining_utility = np.mean(distance_matrix[np.ix_(unvisited_nodes, unvisited_nodes)], axis=1)\n    remaining_utility = (remaining_utility - remaining_utility.min()) / (remaining_utility.max() - remaining_utility.min() + 1e-9)\n    \n    if destination_node in unvisited_nodes:\n        dest_alignment = (distance_matrix[destination_node, unvisited_nodes] - distance_matrix[destination_node, unvisited_nodes].min()) / (distance_matrix[destination_node, unvisited_nodes].max() - distance_matrix[destination_node, unvisited_nodes].min() + 1e-9)\n        dest_alignment = 1 - dest_alignment\n    else:\n        dest_alignment = np.ones(n_unvisited)\n    \n    w_prox = 0.5 - 0.3 * progress\n    w_entropy = 0.2 + 0.2 * progress\n    w_utility = 0.2\n    w_dest = 0.1 + 0.1 * progress\n    \n    scores = w_prox * proximity + w_entropy * entropy_weights + w_utility * remaining_utility + w_dest * dest_alignment\n    next_node_index = np.argmax(scores)\n    next_node = unvisited_nodes[next_node_index]\n    return next_node",
               "objective": 7.1031,
               "other_inf": [
                    "    if len(unvisited_nodes) == 1:",
                    "        return unvisited_nodes[0]",
                    "    n_unvisited = len(unvisited_nodes)",
                    "    progress = 1 - (n_unvisited / (distance_matrix.shape[0] - 1))",
                    "    dist_to_unvisited = distance_matrix[current_node, unvisited_nodes]",
                    "    proximity = 1 / (dist_to_unvisited + 1e-9)",
                    "    entropy_weights = np.zeros(n_unvisited)",
                    "    for idx, node in enumerate(unvisited_nodes):",
                    "        dist_to_others = distance_matrix[node, np.setdiff1d(unvisited_nodes, node)]",
                    "        if len(dist_to_others) > 0:",
                    "            hist, _ = np.histogram(dist_to_others, bins=5)",
                    "            probs = hist / len(dist_to_others) + 1e-9",
                    "            entropy = -np.sum(probs * np.log(probs))",
                    "            entropy_weights[idx] = entropy",
                    "    entropy_weights = (entropy_weights - entropy_weights.min()) / (entropy_weights.max() - entropy_weights.min() + 1e-9)",
                    "    remaining_utility = np.mean(distance_matrix[np.ix_(unvisited_nodes, unvisited_nodes)], axis=1)",
                    "    remaining_utility = (remaining_utility - remaining_utility.min()) / (remaining_utility.max() - remaining_utility.min() + 1e-9)",
                    "    if destination_node in unvisited_nodes:",
                    "        dest_alignment = (distance_matrix[destination_node, unvisited_nodes] - distance_matrix[destination_node, unvisited_nodes].min()) / (distance_matrix[destination_node, unvisited_nodes].max() - distance_matrix[destination_node, unvisited_nodes].min() + 1e-9)",
                    "        dest_alignment = 1 - dest_alignment",
                    "    else:",
                    "        dest_alignment = np.ones(n_unvisited)",
                    "    w_prox = 0.5 - 0.3 * progress",
                    "    w_entropy = 0.2 + 0.2 * progress",
                    "    w_utility = 0.2",
                    "    w_dest = 0.1 + 0.1 * progress",
                    "    scores = w_prox * proximity + w_entropy * entropy_weights + w_utility * remaining_utility + w_dest * dest_alignment"
               ]
          },
          {
               "algorithm": "An algorithm that selects the next node based on a potential field combining harmonic centrality in the unvisited subgraph, simulated repulsion from the future return path, and a turbulence factor for diversification, with annealing on the tour progress.",
               "code": "import numpy as np\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    \n    n_unvisited = len(unvisited_nodes)                                \n                                                                                                                                                              \n    proximity = np.exp(-distance_matrix[current_node, unvisited_nodes] / (np.mean(distance_matrix[current_node, unvisited_nodes]) + 1e-9))\n    \n    degree_weight = np.sum(1 / (distance_matrix[np.ix_(unvisited_nodes, unvisited_nodes)] + np.eye(n_unvisited) * 1e9), axis=1)\n    closeness_weight = np.sum(1 / (distance_matrix[np.ix_(unvisited_nodes, unvisited_nodes)] + 1e-9), axis=1)\n    harmonic_centrality = degree_weight * closeness_weight\n    harmonic_centrality = (harmonic_centrality - harmonic_centrality.min()) / (harmonic_centrality.max() - harmonic_centrality.min() + 1e-9)\n    \n    future_path_repulsion = np.zeros(n_unvisited)\n    if n_unvisited > 1:\n        for idx, node in enumerate(unvisited_nodes):\n            remaining = np.setdiff1d(unvisited_nodes, node)\n            min_to_rest = np.min(distance_matrix[node, remaining])\n            min_to_dest = np.min(distance_matrix[destination_node, remaining])\n            future_path_repulsion[idx] = min_to_rest + min_to_dest\n        future_path_repulsion = 1 / (future_path_repulsion + 1e-9)\n        future_path_repulsion = (future_path_repulsion - future_path_repulsion.min()) / (future_path_repulsion.max() - future_path_repulsion.min() + 1e-9)\n    \n    turbulence = np.random.rand(n_unvisited) ** (1 / (np.mean(distance_matrix[current_node, unvisited_nodes]) + 1))\n    \n    progress = 1 - (n_unvisited / (distance_matrix.shape[0] - 1))\n    w_prox = 0.4 - 0.3 * progress\n    w_central = 0.3 + 0.2 * progress\n    w_repulse = 0.2 - 0.1 * progress\n    w_turb = 0.1 + 0.2 * (1 - progress)\n    \n    scores = w_prox * proximity + w_central * harmonic_centrality + w_repulse * future_path_repulsion + w_turb * turbulence\n    next_index = np.argmax(scores)\n    next_node = unvisited_nodes[next_index]\n    return next_node",
               "objective": 23.81856,
               "other_inf": [
                    "    proximity = np.exp(-distance_matrix[current_node, unvisited_nodes] / (np.mean(distance_matrix[current_node, unvisited_nodes]) + 1e-9))",
                    "    degree_weight = np.sum(1 / (distance_matrix[np.ix_(unvisited_nodes, unvisited_nodes)] + np.eye(n_unvisited) * 1e9), axis=1)",
                    "    closeness_weight = np.sum(1 / (distance_matrix[np.ix_(unvisited_nodes, unvisited_nodes)] + 1e-9), axis=1)",
                    "    harmonic_centrality = degree_weight * closeness_weight",
                    "    harmonic_centrality = (harmonic_centrality - harmonic_centrality.min()) / (harmonic_centrality.max() - harmonic_centrality.min() + 1e-9)",
                    "    future_path_repulsion = np.zeros(n_unvisited)",
                    "    if n_unvisited > 1:",
                    "            remaining = np.setdiff1d(unvisited_nodes, node)",
                    "            min_to_rest = np.min(distance_matrix[node, remaining])",
                    "            min_to_dest = np.min(distance_matrix[destination_node, remaining])",
                    "            future_path_repulsion[idx] = min_to_rest + min_to_dest",
                    "        future_path_repulsion = 1 / (future_path_repulsion + 1e-9)",
                    "        future_path_repulsion = (future_path_repulsion - future_path_repulsion.min()) / (future_path_repulsion.max() - future_path_repulsion.min() + 1e-9)",
                    "    turbulence = np.random.rand(n_unvisited) ** (1 / (np.mean(distance_matrix[current_node, unvisited_nodes]) + 1))",
                    "    w_prox = 0.4 - 0.3 * progress",
                    "    w_central = 0.3 + 0.2 * progress",
                    "    w_repulse = 0.2 - 0.1 * progress",
                    "    w_turb = 0.1 + 0.2 * (1 - progress)",
                    "    scores = w_prox * proximity + w_central * harmonic_centrality + w_repulse * future_path_repulsion + w_turb * turbulence",
                    "    next_index = np.argmax(scores)",
                    "    next_node = unvisited_nodes[next_index]"
               ]
          }
     ],
     [
          {
               "algorithm": "The algorithm selects the next node by combining exponentially decaying proximity, dynamic spatial entropy-based exploration, remaining node utility, and alignment toward the final destination, using adaptive weighting that shifts from exploration to exploitation as the tour progresses.",
               "code": "import numpy as np\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if len(unvisited_nodes) == 1:\n        return unvisited_nodes[0]\n    \n    n_unvisited = len(unvisited_nodes)\n    progress = 1 - (n_unvisited / (distance_matrix.shape[0] - 1))\n    \n    dist_to_unvisited = distance_matrix[current_node, unvisited_nodes]\n    proximity = 1 / (dist_to_unvisited + 1e-9)\n    \n    entropy_weights = np.zeros(n_unvisited)\n    for idx, node in enumerate(unvisited_nodes):\n        dist_to_others = distance_matrix[node, np.setdiff1d(unvisited_nodes, node)]\n        if len(dist_to_others) > 0:\n            hist, _ = np.histogram(dist_to_others, bins=5)\n            probs = hist / len(dist_to_others) + 1e-9\n            entropy = -np.sum(probs * np.log(probs))\n            entropy_weights[idx] = entropy\n    entropy_weights = (entropy_weights - entropy_weights.min()) / (entropy_weights.max() - entropy_weights.min() + 1e-9)\n    \n    remaining_utility = np.mean(distance_matrix[np.ix_(unvisited_nodes, unvisited_nodes)], axis=1)\n    remaining_utility = (remaining_utility - remaining_utility.min()) / (remaining_utility.max() - remaining_utility.min() + 1e-9)\n    \n    if destination_node in unvisited_nodes:\n        dest_alignment = (distance_matrix[destination_node, unvisited_nodes] - distance_matrix[destination_node, unvisited_nodes].min()) / (distance_matrix[destination_node, unvisited_nodes].max() - distance_matrix[destination_node, unvisited_nodes].min() + 1e-9)\n        dest_alignment = 1 - dest_alignment\n    else:\n        dest_alignment = np.ones(n_unvisited)\n    \n    w_prox = 0.5 - 0.3 * progress\n    w_entropy = 0.2 + 0.2 * progress\n    w_utility = 0.2\n    w_dest = 0.1 + 0.1 * progress\n    \n    scores = w_prox * proximity + w_entropy * entropy_weights + w_utility * remaining_utility + w_dest * dest_alignment\n    next_node_index = np.argmax(scores)\n    next_node = unvisited_nodes[next_node_index]\n    return next_node",
               "objective": 7.1031,
               "other_inf": [
                    "    if len(unvisited_nodes) == 1:",
                    "        return unvisited_nodes[0]",
                    "    n_unvisited = len(unvisited_nodes)",
                    "    progress = 1 - (n_unvisited / (distance_matrix.shape[0] - 1))",
                    "    dist_to_unvisited = distance_matrix[current_node, unvisited_nodes]",
                    "    proximity = 1 / (dist_to_unvisited + 1e-9)",
                    "    entropy_weights = np.zeros(n_unvisited)",
                    "    for idx, node in enumerate(unvisited_nodes):",
                    "        dist_to_others = distance_matrix[node, np.setdiff1d(unvisited_nodes, node)]",
                    "        if len(dist_to_others) > 0:",
                    "            hist, _ = np.histogram(dist_to_others, bins=5)",
                    "            probs = hist / len(dist_to_others) + 1e-9",
                    "            entropy = -np.sum(probs * np.log(probs))",
                    "            entropy_weights[idx] = entropy",
                    "    entropy_weights = (entropy_weights - entropy_weights.min()) / (entropy_weights.max() - entropy_weights.min() + 1e-9)",
                    "    remaining_utility = np.mean(distance_matrix[np.ix_(unvisited_nodes, unvisited_nodes)], axis=1)",
                    "    remaining_utility = (remaining_utility - remaining_utility.min()) / (remaining_utility.max() - remaining_utility.min() + 1e-9)",
                    "    if destination_node in unvisited_nodes:",
                    "        dest_alignment = (distance_matrix[destination_node, unvisited_nodes] - distance_matrix[destination_node, unvisited_nodes].min()) / (distance_matrix[destination_node, unvisited_nodes].max() - distance_matrix[destination_node, unvisited_nodes].min() + 1e-9)",
                    "        dest_alignment = 1 - dest_alignment",
                    "    else:",
                    "        dest_alignment = np.ones(n_unvisited)",
                    "    w_prox = 0.5 - 0.3 * progress",
                    "    w_entropy = 0.2 + 0.2 * progress",
                    "    w_utility = 0.2",
                    "    w_dest = 0.1 + 0.1 * progress",
                    "    scores = w_prox * proximity + w_entropy * entropy_weights + w_utility * remaining_utility + w_dest * dest_alignment"
               ]
          },
          {
               "algorithm": "The algorithm selects the next node by combining distance-weighted pheromone accumulation from a simulated local diffusion process, geometric sector density penalization, and a return-pressure heuristic that anticipates the final closure to the destination, with weights adjusted by a simulated annealing style temperature.",
               "code": "import numpy as np\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if len(unvisited_nodes) == 1:\n        return unvisited_nodes[0]\n\n    n_unvisited = len(unvisited_nodes)\n    dist_to_unvisited = distance_matrix[current_node, unvisited_nodes]\n    proximity = 1 / (dist_to_unvisited + 1e-9)\n    \n    entropy_list = []\n    for node in unvisited_nodes:\n        dist_to_others = distance_matrix[node, np.setdiff1d(unvisited_nodes, node)]\n        if len(dist_to_others) > 0:\n            prob = 1 / (dist_to_others + 1e-9)\n            prob = prob / prob.sum()\n            entropy = -np.sum(prob * np.log(prob + 1e-9))\n            entropy_list.append(entropy)\n        else:\n            entropy_list.append(0)\n    spatial_entropy = np.array(entropy_list)\n    \n    remaining_utility = np.mean(distance_matrix[np.ix_(unvisited_nodes, unvisited_nodes)], axis=1)\n    remaining_utility = (remaining_utility - remaining_utility.min()) / (remaining_utility.max() - remaining_utility.min() + 1e-9)\n    \n    dest_alignment = (distance_matrix[destination_node, unvisited_nodes] - distance_matrix[destination_node, unvisited_nodes].min()) / (distance_matrix[destination_node, unvisited_nodes].max() - distance_matrix[destination_node, unvisited_nodes].min() + 1e-9)\n    \n    progress = 1 - n_unvisited / distance_matrix.shape[0]\n    exploit_weight = 0.2 + 0.6 * progress\n    \n    scores = (exploit_weight * proximity +\n              (1 - exploit_weight) * (spatial_entropy - spatial_entropy.min()) / (spatial_entropy.max() - spatial_entropy.min() + 1e-9) +\n              0.3 * remaining_utility -\n              0.2 * dest_alignment)\n    \n    next_node_index = np.argmax(scores)\n    next_node = unvisited_nodes[next_node_index]\n    return next_node",
               "objective": 7.04665,
               "other_inf": [
                    "    entropy_list = []",
                    "    for node in unvisited_nodes:",
                    "            prob = 1 / (dist_to_others + 1e-9)",
                    "            prob = prob / prob.sum()",
                    "            entropy = -np.sum(prob * np.log(prob + 1e-9))",
                    "            entropy_list.append(entropy)",
                    "            entropy_list.append(0)",
                    "    spatial_entropy = np.array(entropy_list)",
                    "    progress = 1 - n_unvisited / distance_matrix.shape[0]",
                    "    exploit_weight = 0.2 + 0.6 * progress",
                    "    scores = (exploit_weight * proximity +",
                    "              (1 - exploit_weight) * (spatial_entropy - spatial_entropy.min()) / (spatial_entropy.max() - spatial_entropy.min() + 1e-9) +",
                    "              0.3 * remaining_utility -",
                    "              0.2 * dest_alignment)"
               ]
          }
     ],
     [
          {
               "algorithm": "The algorithm selects the next node by combining distance-weighted pheromone accumulation from a simulated local diffusion process, geometric sector density penalization, and a return-pressure heuristic that anticipates the final closure to the destination, with weights adjusted by a simulated annealing style temperature.",
               "code": "import numpy as np\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if len(unvisited_nodes) == 1:\n        return unvisited_nodes[0]\n\n    n_unvisited = len(unvisited_nodes)\n    dist_to_unvisited = distance_matrix[current_node, unvisited_nodes]\n    proximity = 1 / (dist_to_unvisited + 1e-9)\n    \n    entropy_list = []\n    for node in unvisited_nodes:\n        dist_to_others = distance_matrix[node, np.setdiff1d(unvisited_nodes, node)]\n        if len(dist_to_others) > 0:\n            prob = 1 / (dist_to_others + 1e-9)\n            prob = prob / prob.sum()\n            entropy = -np.sum(prob * np.log(prob + 1e-9))\n            entropy_list.append(entropy)\n        else:\n            entropy_list.append(0)\n    spatial_entropy = np.array(entropy_list)\n    \n    remaining_utility = np.mean(distance_matrix[np.ix_(unvisited_nodes, unvisited_nodes)], axis=1)\n    remaining_utility = (remaining_utility - remaining_utility.min()) / (remaining_utility.max() - remaining_utility.min() + 1e-9)\n    \n    dest_alignment = (distance_matrix[destination_node, unvisited_nodes] - distance_matrix[destination_node, unvisited_nodes].min()) / (distance_matrix[destination_node, unvisited_nodes].max() - distance_matrix[destination_node, unvisited_nodes].min() + 1e-9)\n    \n    progress = 1 - n_unvisited / distance_matrix.shape[0]\n    exploit_weight = 0.2 + 0.6 * progress\n    \n    scores = (exploit_weight * proximity +\n              (1 - exploit_weight) * (spatial_entropy - spatial_entropy.min()) / (spatial_entropy.max() - spatial_entropy.min() + 1e-9) +\n              0.3 * remaining_utility -\n              0.2 * dest_alignment)\n    \n    next_node_index = np.argmax(scores)\n    next_node = unvisited_nodes[next_node_index]\n    return next_node",
               "objective": 7.04665,
               "other_inf": [
                    "    entropy_list = []",
                    "    for node in unvisited_nodes:",
                    "            prob = 1 / (dist_to_others + 1e-9)",
                    "            prob = prob / prob.sum()",
                    "            entropy = -np.sum(prob * np.log(prob + 1e-9))",
                    "            entropy_list.append(entropy)",
                    "            entropy_list.append(0)",
                    "    spatial_entropy = np.array(entropy_list)",
                    "    progress = 1 - n_unvisited / distance_matrix.shape[0]",
                    "    exploit_weight = 0.2 + 0.6 * progress",
                    "    scores = (exploit_weight * proximity +",
                    "              (1 - exploit_weight) * (spatial_entropy - spatial_entropy.min()) / (spatial_entropy.max() - spatial_entropy.min() + 1e-9) +",
                    "              0.3 * remaining_utility -",
                    "              0.2 * dest_alignment)"
               ]
          },
          {
               "algorithm": "The algorithm selects the next node by combining a distance-weighted potential field, a cluster-aware angular dispersion score, and a look-ahead path smoothness estimator, with adaptive balancing using a progressive exploration-decay parameter.",
               "code": "import numpy as np\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if len(unvisited_nodes) == 0:\n        return destination_node\n    if len(unvisited_nodes) == 1:\n        return unvisited_nodes[0]\n\n    n_nodes = distance_matrix.shape[0]\n    n_unvisited = len(unvisited_nodes)\n    dists_to_current = distance_matrix[current_node, unvisited_nodes]\n    dists_to_dest = distance_matrix[destination_node, unvisited_nodes]\n    \n    proximity = 1.0 / (dists_to_current + 1e-9)\n    \n    coords = np.random.randn(n_nodes, 2)\n    vectors = coords[unvisited_nodes] - coords[current_node]\n    norms = np.linalg.norm(vectors, axis=1)\n    unit_vectors = vectors / (norms[:, None] + 1e-9)\n    pairwise_cos = np.clip(np.dot(unit_vectors, unit_vectors.T), -1, 1)\n    angular_dispersion = 1.0 / (np.sum(pairwise_cos, axis=1) + 1e-3)\n    \n    look_ahead_smoothness = []\n    for i, cand in enumerate(unvisited_nodes):\n        remain = unvisited_nodes[unvisited_nodes != cand]\n        if len(remain) == 0:\n            look_ahead_smoothness.append(0)\n        else:\n            avg_return_dist = np.mean(distance_matrix[remain, destination_node])\n            avg_inter_dist = np.mean(distance_matrix[remain, cand])\n            look_ahead_smoothness.append(avg_return_dist + avg_inter_dist)\n    look_ahead_smoothness = np.array(look_ahead_smoothness)\n    look_ahead_smoothness = (look_ahead_smoothness.max() - look_ahead_smoothness) / (look_ahead_smoothness.max() - look_ahead_smoothness.min() + 1e-9)\n    \n    progress = 1.0 - (n_unvisited / n_nodes)\n    exploit_weight = 0.7 + 0.3 * progress\n    explore_weight = 1.0 - exploit_weight\n    \n    scores = (exploit_weight * proximity) + (explore_weight * angular_dispersion) + look_ahead_smoothness\n    next_node_index = np.argmax(scores)\n    next_node = unvisited_nodes[next_node_index]\n    return next_node",
               "objective": 8.02587,
               "other_inf": [
                    "    if len(unvisited_nodes) == 0:",
                    "        return destination_node",
                    "    n_nodes = distance_matrix.shape[0]",
                    "    dists_to_current = distance_matrix[current_node, unvisited_nodes]",
                    "    dists_to_dest = distance_matrix[destination_node, unvisited_nodes]",
                    "    proximity = 1.0 / (dists_to_current + 1e-9)",
                    "    coords = np.random.randn(n_nodes, 2)",
                    "    vectors = coords[unvisited_nodes] - coords[current_node]",
                    "    norms = np.linalg.norm(vectors, axis=1)",
                    "    unit_vectors = vectors / (norms[:, None] + 1e-9)",
                    "    pairwise_cos = np.clip(np.dot(unit_vectors, unit_vectors.T), -1, 1)",
                    "    angular_dispersion = 1.0 / (np.sum(pairwise_cos, axis=1) + 1e-3)",
                    "    look_ahead_smoothness = []",
                    "    for i, cand in enumerate(unvisited_nodes):",
                    "        remain = unvisited_nodes[unvisited_nodes != cand]",
                    "        if len(remain) == 0:",
                    "            look_ahead_smoothness.append(0)",
                    "            avg_return_dist = np.mean(distance_matrix[remain, destination_node])",
                    "            avg_inter_dist = np.mean(distance_matrix[remain, cand])",
                    "            look_ahead_smoothness.append(avg_return_dist + avg_inter_dist)",
                    "    look_ahead_smoothness = np.array(look_ahead_smoothness)",
                    "    look_ahead_smoothness = (look_ahead_smoothness.max() - look_ahead_smoothness) / (look_ahead_smoothness.max() - look_ahead_smoothness.min() + 1e-9)",
                    "    progress = 1.0 - (n_unvisited / n_nodes)",
                    "    exploit_weight = 0.7 + 0.3 * progress",
                    "    explore_weight = 1.0 - exploit_weight",
                    "    scores = (exploit_weight * proximity) + (explore_weight * angular_dispersion) + look_ahead_smoothness"
               ]
          }
     ],
     [
          {
               "algorithm": "The algorithm selects the next node by combining distance-weighted pheromone accumulation from a simulated local diffusion process, geometric sector density penalization, and a return-pressure heuristic that anticipates the final closure to the destination, with weights adjusted by a simulated annealing style temperature.",
               "code": "import numpy as np\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if len(unvisited_nodes) == 1:\n        return unvisited_nodes[0]\n\n    n_unvisited = len(unvisited_nodes)\n    dist_to_unvisited = distance_matrix[current_node, unvisited_nodes]\n    proximity = 1 / (dist_to_unvisited + 1e-9)\n    \n    entropy_list = []\n    for node in unvisited_nodes:\n        dist_to_others = distance_matrix[node, np.setdiff1d(unvisited_nodes, node)]\n        if len(dist_to_others) > 0:\n            prob = 1 / (dist_to_others + 1e-9)\n            prob = prob / prob.sum()\n            entropy = -np.sum(prob * np.log(prob + 1e-9))\n            entropy_list.append(entropy)\n        else:\n            entropy_list.append(0)\n    spatial_entropy = np.array(entropy_list)\n    \n    remaining_utility = np.mean(distance_matrix[np.ix_(unvisited_nodes, unvisited_nodes)], axis=1)\n    remaining_utility = (remaining_utility - remaining_utility.min()) / (remaining_utility.max() - remaining_utility.min() + 1e-9)\n    \n    dest_alignment = (distance_matrix[destination_node, unvisited_nodes] - distance_matrix[destination_node, unvisited_nodes].min()) / (distance_matrix[destination_node, unvisited_nodes].max() - distance_matrix[destination_node, unvisited_nodes].min() + 1e-9)\n    \n    progress = 1 - n_unvisited / distance_matrix.shape[0]\n    exploit_weight = 0.2 + 0.6 * progress\n    \n    scores = (exploit_weight * proximity +\n              (1 - exploit_weight) * (spatial_entropy - spatial_entropy.min()) / (spatial_entropy.max() - spatial_entropy.min() + 1e-9) +\n              0.3 * remaining_utility -\n              0.2 * dest_alignment)\n    \n    next_node_index = np.argmax(scores)\n    next_node = unvisited_nodes[next_node_index]\n    return next_node",
               "objective": 7.04665,
               "other_inf": [
                    "    entropy_list = []",
                    "    for node in unvisited_nodes:",
                    "            prob = 1 / (dist_to_others + 1e-9)",
                    "            prob = prob / prob.sum()",
                    "            entropy = -np.sum(prob * np.log(prob + 1e-9))",
                    "            entropy_list.append(entropy)",
                    "            entropy_list.append(0)",
                    "    spatial_entropy = np.array(entropy_list)",
                    "    progress = 1 - n_unvisited / distance_matrix.shape[0]",
                    "    exploit_weight = 0.2 + 0.6 * progress",
                    "    scores = (exploit_weight * proximity +",
                    "              (1 - exploit_weight) * (spatial_entropy - spatial_entropy.min()) / (spatial_entropy.max() - spatial_entropy.min() + 1e-9) +",
                    "              0.3 * remaining_utility -",
                    "              0.2 * dest_alignment)"
               ]
          },
          {
               "algorithm": "The algorithm selects the next node using a probabilistic blend of greedy proximity, angular dispersion penalty, future return anticipation, and a lookahead penalty based on the minimum spanning tree cost of remaining nodes, dynamically weighted by a progress factor.",
               "code": "import numpy as np\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if len(unvisited_nodes) == 1:\n        return unvisited_nodes[0]\n    \n    progress = 1 - len(unvisited_nodes) / (distance_matrix.shape[0] - 1)\n    inv_distance = 1 / (distance_matrix[current_node, unvisited_nodes] + 1e-9)\n    proximity = inv_distance / np.max(inv_distance)\n    \n    centroid = np.mean([np.array([distance_matrix[node, 0], distance_matrix[node, 1]]) if distance_matrix.ndim > 1 else np.array([0,0]) for node in unvisited_nodes], axis=0)\n    vectors = np.array([(distance_matrix[node, 0] - centroid[0], distance_matrix[node, 1] - centroid[1]) if distance_matrix.ndim > 1 else (0,0) for node in unvisited_nodes])\n    angles = np.arctan2(vectors[:,1], vectors[:,0])\n    diff_matrix = np.abs(angles[:, None] - angles)\n    diff_matrix = np.minimum(diff_matrix, 2 * np.pi - diff_matrix)\n    dispersion = np.sum(diff_matrix, axis=1) / len(unvisited_nodes)\n    dispersion = dispersion / (np.max(dispersion) + 1e-9)\n    \n    return_cost = distance_matrix[destination_node, unvisited_nodes]\n    return_cost = 1 - (return_cost - np.min(return_cost)) / (np.max(return_cost) - np.min(return_cost) + 1e-9)\n    \n    if len(unvisited_nodes) > 2:\n        sub_dist = distance_matrix[np.ix_(unvisited_nodes, unvisited_nodes)]\n        mst_cost = 0\n        for i in range(len(unvisited_nodes)):\n            min_vals = np.partition(sub_dist[i], 1)[1]\n            mst_cost += min_vals\n        mst_penalty = (mst_cost - np.min(mst_cost)) / (np.max(mst_cost) - np.min(mst_cost) + 1e-9)\n    else:\n        mst_penalty = np.zeros(len(unvisited_nodes))\n    \n    exploit = 0.3 + 0.5 * progress\n    scores = (exploit * proximity + \n              (1 - exploit) * (1 - dispersion) + \n              0.2 * return_cost - \n              0.1 * mst_penalty)\n    \n    probabilities = np.exp(scores) / np.sum(np.exp(scores))\n    next_node_index = np.random.choice(range(len(unvisited_nodes)), p=probabilities)\n    next_node = unvisited_nodes[next_node_index]\n    return next_node",
               "objective": 25.15283,
               "other_inf": [
                    "    progress = 1 - len(unvisited_nodes) / (distance_matrix.shape[0] - 1)",
                    "    inv_distance = 1 / (distance_matrix[current_node, unvisited_nodes] + 1e-9)",
                    "    proximity = inv_distance / np.max(inv_distance)",
                    "    centroid = np.mean([np.array([distance_matrix[node, 0], distance_matrix[node, 1]]) if distance_matrix.ndim > 1 else np.array([0,0]) for node in unvisited_nodes], axis=0)",
                    "    vectors = np.array([(distance_matrix[node, 0] - centroid[0], distance_matrix[node, 1] - centroid[1]) if distance_matrix.ndim > 1 else (0,0) for node in unvisited_nodes])",
                    "    angles = np.arctan2(vectors[:,1], vectors[:,0])",
                    "    diff_matrix = np.abs(angles[:, None] - angles)",
                    "    diff_matrix = np.minimum(diff_matrix, 2 * np.pi - diff_matrix)",
                    "    dispersion = np.sum(diff_matrix, axis=1) / len(unvisited_nodes)",
                    "    dispersion = dispersion / (np.max(dispersion) + 1e-9)",
                    "    return_cost = distance_matrix[destination_node, unvisited_nodes]",
                    "    return_cost = 1 - (return_cost - np.min(return_cost)) / (np.max(return_cost) - np.min(return_cost) + 1e-9)",
                    "    if len(unvisited_nodes) > 2:",
                    "        sub_dist = distance_matrix[np.ix_(unvisited_nodes, unvisited_nodes)]",
                    "        mst_cost = 0",
                    "        for i in range(len(unvisited_nodes)):",
                    "            min_vals = np.partition(sub_dist[i], 1)[1]",
                    "            mst_cost += min_vals",
                    "        mst_penalty = (mst_cost - np.min(mst_cost)) / (np.max(mst_cost) - np.min(mst_cost) + 1e-9)",
                    "        mst_penalty = np.zeros(len(unvisited_nodes))",
                    "    exploit = 0.3 + 0.5 * progress",
                    "    scores = (exploit * proximity +",
                    "              (1 - exploit) * (1 - dispersion) +",
                    "              0.2 * return_cost -",
                    "              0.1 * mst_penalty)",
                    "    probabilities = np.exp(scores) / np.sum(np.exp(scores))",
                    "    next_node_index = np.random.choice(range(len(unvisited_nodes)), p=probabilities)"
               ]
          }
     ],
     [
          {
               "algorithm": "The algorithm selects the next node by combining distance-weighted pheromone accumulation from a simulated local diffusion process, geometric sector density penalization, and a return-pressure heuristic that anticipates the final closure to the destination, with weights adjusted by a simulated annealing style temperature.",
               "code": "import numpy as np\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if len(unvisited_nodes) == 1:\n        return unvisited_nodes[0]\n\n    n_unvisited = len(unvisited_nodes)\n    dist_to_unvisited = distance_matrix[current_node, unvisited_nodes]\n    proximity = 1 / (dist_to_unvisited + 1e-9)\n    \n    entropy_list = []\n    for node in unvisited_nodes:\n        dist_to_others = distance_matrix[node, np.setdiff1d(unvisited_nodes, node)]\n        if len(dist_to_others) > 0:\n            prob = 1 / (dist_to_others + 1e-9)\n            prob = prob / prob.sum()\n            entropy = -np.sum(prob * np.log(prob + 1e-9))\n            entropy_list.append(entropy)\n        else:\n            entropy_list.append(0)\n    spatial_entropy = np.array(entropy_list)\n    \n    remaining_utility = np.mean(distance_matrix[np.ix_(unvisited_nodes, unvisited_nodes)], axis=1)\n    remaining_utility = (remaining_utility - remaining_utility.min()) / (remaining_utility.max() - remaining_utility.min() + 1e-9)\n    \n    dest_alignment = (distance_matrix[destination_node, unvisited_nodes] - distance_matrix[destination_node, unvisited_nodes].min()) / (distance_matrix[destination_node, unvisited_nodes].max() - distance_matrix[destination_node, unvisited_nodes].min() + 1e-9)\n    \n    progress = 1 - n_unvisited / distance_matrix.shape[0]\n    exploit_weight = 0.2 + 0.6 * progress\n    \n    scores = (exploit_weight * proximity +\n              (1 - exploit_weight) * (spatial_entropy - spatial_entropy.min()) / (spatial_entropy.max() - spatial_entropy.min() + 1e-9) +\n              0.3 * remaining_utility -\n              0.2 * dest_alignment)\n    \n    next_node_index = np.argmax(scores)\n    next_node = unvisited_nodes[next_node_index]\n    return next_node",
               "objective": 7.04665,
               "other_inf": [
                    "    entropy_list = []",
                    "    for node in unvisited_nodes:",
                    "            prob = 1 / (dist_to_others + 1e-9)",
                    "            prob = prob / prob.sum()",
                    "            entropy = -np.sum(prob * np.log(prob + 1e-9))",
                    "            entropy_list.append(entropy)",
                    "            entropy_list.append(0)",
                    "    spatial_entropy = np.array(entropy_list)",
                    "    progress = 1 - n_unvisited / distance_matrix.shape[0]",
                    "    exploit_weight = 0.2 + 0.6 * progress",
                    "    scores = (exploit_weight * proximity +",
                    "              (1 - exploit_weight) * (spatial_entropy - spatial_entropy.min()) / (spatial_entropy.max() - spatial_entropy.min() + 1e-9) +",
                    "              0.3 * remaining_utility -",
                    "              0.2 * dest_alignment)"
               ]
          },
          {
               "algorithm": null,
               "code": null,
               "objective": null,
               "other_inf": null
          }
     ],
     [
          {
               "algorithm": "The algorithm selects the next node by combining distance-weighted pheromone accumulation from a simulated local diffusion process, geometric sector density penalization, and a return-pressure heuristic that anticipates the final closure to the destination, with weights adjusted by a simulated annealing style temperature.",
               "code": "import numpy as np\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if len(unvisited_nodes) == 1:\n        return unvisited_nodes[0]\n\n    n_unvisited = len(unvisited_nodes)\n    dist_to_unvisited = distance_matrix[current_node, unvisited_nodes]\n    proximity = 1 / (dist_to_unvisited + 1e-9)\n    \n    entropy_list = []\n    for node in unvisited_nodes:\n        dist_to_others = distance_matrix[node, np.setdiff1d(unvisited_nodes, node)]\n        if len(dist_to_others) > 0:\n            prob = 1 / (dist_to_others + 1e-9)\n            prob = prob / prob.sum()\n            entropy = -np.sum(prob * np.log(prob + 1e-9))\n            entropy_list.append(entropy)\n        else:\n            entropy_list.append(0)\n    spatial_entropy = np.array(entropy_list)\n    \n    remaining_utility = np.mean(distance_matrix[np.ix_(unvisited_nodes, unvisited_nodes)], axis=1)\n    remaining_utility = (remaining_utility - remaining_utility.min()) / (remaining_utility.max() - remaining_utility.min() + 1e-9)\n    \n    dest_alignment = (distance_matrix[destination_node, unvisited_nodes] - distance_matrix[destination_node, unvisited_nodes].min()) / (distance_matrix[destination_node, unvisited_nodes].max() - distance_matrix[destination_node, unvisited_nodes].min() + 1e-9)\n    \n    progress = 1 - n_unvisited / distance_matrix.shape[0]\n    exploit_weight = 0.2 + 0.6 * progress\n    \n    scores = (exploit_weight * proximity +\n              (1 - exploit_weight) * (spatial_entropy - spatial_entropy.min()) / (spatial_entropy.max() - spatial_entropy.min() + 1e-9) +\n              0.3 * remaining_utility -\n              0.2 * dest_alignment)\n    \n    next_node_index = np.argmax(scores)\n    next_node = unvisited_nodes[next_node_index]\n    return next_node",
               "objective": 7.04665,
               "other_inf": [
                    "    entropy_list = []",
                    "    for node in unvisited_nodes:",
                    "            prob = 1 / (dist_to_others + 1e-9)",
                    "            prob = prob / prob.sum()",
                    "            entropy = -np.sum(prob * np.log(prob + 1e-9))",
                    "            entropy_list.append(entropy)",
                    "            entropy_list.append(0)",
                    "    spatial_entropy = np.array(entropy_list)",
                    "    progress = 1 - n_unvisited / distance_matrix.shape[0]",
                    "    exploit_weight = 0.2 + 0.6 * progress",
                    "    scores = (exploit_weight * proximity +",
                    "              (1 - exploit_weight) * (spatial_entropy - spatial_entropy.min()) / (spatial_entropy.max() - spatial_entropy.min() + 1e-9) +",
                    "              0.3 * remaining_utility -",
                    "              0.2 * dest_alignment)"
               ]
          },
          {
               "algorithm": "The algorithm selects the next node using a temperature-annealed Gibbs sampling from a geometric mean of normalized proximity, cluster connectivity, and destination alignment factors.",
               "code": "import numpy as np\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if len(unvisited_nodes) == 1:\n        return unvisited_nodes[0]\n\n    n_unvisited = len(unvisited_nodes)\n    dist_to_unvisited = distance_matrix[current_node, unvisited_nodes]\n    proximity = 1 / (dist_to_unvisited + 1e-9)\n    \n    proximity = proximity / proximity.sum()\n    \n    remaining_utility = np.mean(distance_matrix[np.ix_(unvisited_nodes, unvisited_nodes)], axis=1)\n    remaining_utility = 1 / (remaining_utility + 1e-9)\n    remaining_utility = remaining_utility / remaining_utility.sum()\n    \n    dest_alignment = (distance_matrix[destination_node, unvisited_nodes] - distance_matrix[destination_node, unvisited_nodes].min()) / (distance_matrix[destination_node, unvisited_nodes].max() - distance_matrix[destination_node, unvisited_nodes].min() + 1e-9)\n    dest_alignment = 1 - dest_alignment\n    dest_alignment = dest_alignment / dest_alignment.sum()\n    \n    progress = 1 - n_unvisited / (distance_matrix.shape[0] - 1)\n    T_init = 2.0\n    T = T_init * (1 - progress)\n    \n    combined_score = proximity**0.4 * remaining_utility**0.3 * dest_alignment**0.3\n    eps = 1e-12\n    log_prob = np.log(combined_score + eps)\n    \n    perturbed = log_prob + T * np.random.randn(n_unvisited)\n    softmax = np.exp(perturbed - np.max(perturbed))\n    softmax = softmax / softmax.sum()\n    \n    next_idx = np.random.choice(np.arange(n_unvisited), p=softmax)\n    next_node = unvisited_nodes[next_idx]\n    \n    return next_node",
               "objective": 24.29298,
               "other_inf": [
                    "    proximity = proximity / proximity.sum()",
                    "    remaining_utility = 1 / (remaining_utility + 1e-9)",
                    "    remaining_utility = remaining_utility / remaining_utility.sum()",
                    "    dest_alignment = 1 - dest_alignment",
                    "    dest_alignment = dest_alignment / dest_alignment.sum()",
                    "    progress = 1 - n_unvisited / (distance_matrix.shape[0] - 1)",
                    "    T_init = 2.0",
                    "    T = T_init * (1 - progress)",
                    "    combined_score = proximity**0.4 * remaining_utility**0.3 * dest_alignment**0.3",
                    "    eps = 1e-12",
                    "    log_prob = np.log(combined_score + eps)",
                    "    perturbed = log_prob + T * np.random.randn(n_unvisited)",
                    "    softmax = np.exp(perturbed - np.max(perturbed))",
                    "    softmax = softmax / softmax.sum()",
                    "    next_idx = np.random.choice(np.arange(n_unvisited), p=softmax)",
                    "    next_node = unvisited_nodes[next_idx]"
               ]
          }
     ],
     [
          {
               "algorithm": "The algorithm selects the next node by combining distance-weighted pheromone accumulation from a simulated local diffusion process, geometric sector density penalization, and a return-pressure heuristic that anticipates the final closure to the destination, with weights adjusted by a simulated annealing style temperature.",
               "code": "import numpy as np\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if len(unvisited_nodes) == 1:\n        return unvisited_nodes[0]\n\n    n_unvisited = len(unvisited_nodes)\n    dist_to_unvisited = distance_matrix[current_node, unvisited_nodes]\n    proximity = 1 / (dist_to_unvisited + 1e-9)\n    \n    entropy_list = []\n    for node in unvisited_nodes:\n        dist_to_others = distance_matrix[node, np.setdiff1d(unvisited_nodes, node)]\n        if len(dist_to_others) > 0:\n            prob = 1 / (dist_to_others + 1e-9)\n            prob = prob / prob.sum()\n            entropy = -np.sum(prob * np.log(prob + 1e-9))\n            entropy_list.append(entropy)\n        else:\n            entropy_list.append(0)\n    spatial_entropy = np.array(entropy_list)\n    \n    remaining_utility = np.mean(distance_matrix[np.ix_(unvisited_nodes, unvisited_nodes)], axis=1)\n    remaining_utility = (remaining_utility - remaining_utility.min()) / (remaining_utility.max() - remaining_utility.min() + 1e-9)\n    \n    dest_alignment = (distance_matrix[destination_node, unvisited_nodes] - distance_matrix[destination_node, unvisited_nodes].min()) / (distance_matrix[destination_node, unvisited_nodes].max() - distance_matrix[destination_node, unvisited_nodes].min() + 1e-9)\n    \n    progress = 1 - n_unvisited / distance_matrix.shape[0]\n    exploit_weight = 0.2 + 0.6 * progress\n    \n    scores = (exploit_weight * proximity +\n              (1 - exploit_weight) * (spatial_entropy - spatial_entropy.min()) / (spatial_entropy.max() - spatial_entropy.min() + 1e-9) +\n              0.3 * remaining_utility -\n              0.2 * dest_alignment)\n    \n    next_node_index = np.argmax(scores)\n    next_node = unvisited_nodes[next_node_index]\n    return next_node",
               "objective": 7.04665,
               "other_inf": [
                    "    entropy_list = []",
                    "    for node in unvisited_nodes:",
                    "            prob = 1 / (dist_to_others + 1e-9)",
                    "            prob = prob / prob.sum()",
                    "            entropy = -np.sum(prob * np.log(prob + 1e-9))",
                    "            entropy_list.append(entropy)",
                    "            entropy_list.append(0)",
                    "    spatial_entropy = np.array(entropy_list)",
                    "    progress = 1 - n_unvisited / distance_matrix.shape[0]",
                    "    exploit_weight = 0.2 + 0.6 * progress",
                    "    scores = (exploit_weight * proximity +",
                    "              (1 - exploit_weight) * (spatial_entropy - spatial_entropy.min()) / (spatial_entropy.max() - spatial_entropy.min() + 1e-9) +",
                    "              0.3 * remaining_utility -",
                    "              0.2 * dest_alignment)"
               ]
          },
          {
               "algorithm": "The algorithm selects the next node using a dynamic multi-criteria score balancing radial progress toward the destination, angular dispersion of remaining nodes, and a simulated local tension force from neighboring unvisited nodes.",
               "code": "import numpy as np\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if len(unvisited_nodes) == 0:\n        return destination_node\n    \n    dist_to_unvisited = distance_matrix[current_node, unvisited_nodes]\n    dist_to_dest = distance_matrix[current_node, destination_node]\n    \n    # 1. Radial progress: favor moving toward destination region\n    dest_distances = distance_matrix[destination_node, unvisited_nodes]\n    radial = (dist_to_dest - dest_distances) / (dist_to_dest + 1e-9)\n    radial_score = (radial - radial.min()) / (radial.max() - radial.min() + 1e-9)\n    \n    # 2. Angular dispersion: prefer direction that spreads remaining nodes\n    if len(unvisited_nodes) > 1:\n        vectors = np.column_stack([np.cos(unvisited_nodes * 0.01), np.sin(unvisited_nodes * 0.01)])\n        center = vectors.mean(axis=0)\n        angular_disp = np.linalg.norm(vectors - center, axis=1)\n        angular_score = (angular_disp - angular_disp.min()) / (angular_disp.max() - angular_disp.min() + 1e-9)\n    else:\n        angular_score = np.array([0.0])\n    \n    # 3. Local tension: simulated repulsion from nearest unvisited neighbors\n    avg_dist_to_others = np.array([np.mean(distance_matrix[u, np.setdiff1d(unvisited_nodes, u)]) if len(unvisited_nodes) > 1 else 1.0 for u in unvisited_nodes])\n    tension = 1 / (avg_dist_to_others + 1e-9)\n    tension_score = (tension - tension.min()) / (tension.max() - tension.min() + 1e-9)\n    \n    # 4. Proximity weight\n    proximity = 1 / (dist_to_unvisited + 1e-9)\n    proximity_score = (proximity - proximity.min()) / (proximity.max() - proximity.min() + 1e-9)\n    \n    # Dynamic weight based on remaining nodes\n    progress = 1 - len(unvisited_nodes) / (distance_matrix.shape[0] - 1)\n    w_radial = 0.4 + 0.3 * progress\n    w_angular = 0.3 - 0.2 * progress\n    w_tension = 0.2\n    w_proximity = 0.1\n    \n    scores = (w_radial * radial_score + \n              w_angular * angular_score + \n              w_tension * tension_score + \n              w_proximity * proximity_score)\n    \n    next_idx = np.argmax(scores)\n    next_node = unvisited_nodes[next_idx]\n    return next_node",
               "objective": 15.08324,
               "other_inf": [
                    "    if len(unvisited_nodes) == 0:",
                    "        return destination_node",
                    "    dist_to_dest = distance_matrix[current_node, destination_node]",
                    "    dest_distances = distance_matrix[destination_node, unvisited_nodes]",
                    "    radial = (dist_to_dest - dest_distances) / (dist_to_dest + 1e-9)",
                    "    radial_score = (radial - radial.min()) / (radial.max() - radial.min() + 1e-9)",
                    "    if len(unvisited_nodes) > 1:",
                    "        vectors = np.column_stack([np.cos(unvisited_nodes * 0.01), np.sin(unvisited_nodes * 0.01)])",
                    "        center = vectors.mean(axis=0)",
                    "        angular_disp = np.linalg.norm(vectors - center, axis=1)",
                    "        angular_score = (angular_disp - angular_disp.min()) / (angular_disp.max() - angular_disp.min() + 1e-9)",
                    "        angular_score = np.array([0.0])",
                    "    avg_dist_to_others = np.array([np.mean(distance_matrix[u, np.setdiff1d(unvisited_nodes, u)]) if len(unvisited_nodes) > 1 else 1.0 for u in unvisited_nodes])",
                    "    tension = 1 / (avg_dist_to_others + 1e-9)",
                    "    tension_score = (tension - tension.min()) / (tension.max() - tension.min() + 1e-9)",
                    "    proximity_score = (proximity - proximity.min()) / (proximity.max() - proximity.min() + 1e-9)",
                    "    progress = 1 - len(unvisited_nodes) / (distance_matrix.shape[0] - 1)",
                    "    w_radial = 0.4 + 0.3 * progress",
                    "    w_angular = 0.3 - 0.2 * progress",
                    "    w_tension = 0.2",
                    "    w_proximity = 0.1",
                    "    scores = (w_radial * radial_score +",
                    "              w_angular * angular_score +",
                    "              w_tension * tension_score +",
                    "              w_proximity * proximity_score)",
                    "    next_idx = np.argmax(scores)",
                    "    next_node = unvisited_nodes[next_idx]"
               ]
          }
     ],
     [
          {
               "algorithm": "The algorithm selects the next node by combining distance-weighted pheromone accumulation from a simulated local diffusion process, geometric sector density penalization, and a return-pressure heuristic that anticipates the final closure to the destination, with weights adjusted by a simulated annealing style temperature.",
               "code": "import numpy as np\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if len(unvisited_nodes) == 1:\n        return unvisited_nodes[0]\n\n    n_unvisited = len(unvisited_nodes)\n    dist_to_unvisited = distance_matrix[current_node, unvisited_nodes]\n    proximity = 1 / (dist_to_unvisited + 1e-9)\n    \n    entropy_list = []\n    for node in unvisited_nodes:\n        dist_to_others = distance_matrix[node, np.setdiff1d(unvisited_nodes, node)]\n        if len(dist_to_others) > 0:\n            prob = 1 / (dist_to_others + 1e-9)\n            prob = prob / prob.sum()\n            entropy = -np.sum(prob * np.log(prob + 1e-9))\n            entropy_list.append(entropy)\n        else:\n            entropy_list.append(0)\n    spatial_entropy = np.array(entropy_list)\n    \n    remaining_utility = np.mean(distance_matrix[np.ix_(unvisited_nodes, unvisited_nodes)], axis=1)\n    remaining_utility = (remaining_utility - remaining_utility.min()) / (remaining_utility.max() - remaining_utility.min() + 1e-9)\n    \n    dest_alignment = (distance_matrix[destination_node, unvisited_nodes] - distance_matrix[destination_node, unvisited_nodes].min()) / (distance_matrix[destination_node, unvisited_nodes].max() - distance_matrix[destination_node, unvisited_nodes].min() + 1e-9)\n    \n    progress = 1 - n_unvisited / distance_matrix.shape[0]\n    exploit_weight = 0.2 + 0.6 * progress\n    \n    scores = (exploit_weight * proximity +\n              (1 - exploit_weight) * (spatial_entropy - spatial_entropy.min()) / (spatial_entropy.max() - spatial_entropy.min() + 1e-9) +\n              0.3 * remaining_utility -\n              0.2 * dest_alignment)\n    \n    next_node_index = np.argmax(scores)\n    next_node = unvisited_nodes[next_node_index]\n    return next_node",
               "objective": 7.04665,
               "other_inf": [
                    "    entropy_list = []",
                    "    for node in unvisited_nodes:",
                    "            prob = 1 / (dist_to_others + 1e-9)",
                    "            prob = prob / prob.sum()",
                    "            entropy = -np.sum(prob * np.log(prob + 1e-9))",
                    "            entropy_list.append(entropy)",
                    "            entropy_list.append(0)",
                    "    spatial_entropy = np.array(entropy_list)",
                    "    progress = 1 - n_unvisited / distance_matrix.shape[0]",
                    "    exploit_weight = 0.2 + 0.6 * progress",
                    "    scores = (exploit_weight * proximity +",
                    "              (1 - exploit_weight) * (spatial_entropy - spatial_entropy.min()) / (spatial_entropy.max() - spatial_entropy.min() + 1e-9) +",
                    "              0.3 * remaining_utility -",
                    "              0.2 * dest_alignment)"
               ]
          },
          {
               "algorithm": null,
               "code": null,
               "objective": null,
               "other_inf": null
          }
     ],
     [
          {
               "algorithm": "The algorithm selects the next node by combining distance-weighted pheromone accumulation from a simulated local diffusion process, geometric sector density penalization, and a return-pressure heuristic that anticipates the final closure to the destination, with weights adjusted by a simulated annealing style temperature.",
               "code": "import numpy as np\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if len(unvisited_nodes) == 1:\n        return unvisited_nodes[0]\n\n    n_unvisited = len(unvisited_nodes)\n    dist_to_unvisited = distance_matrix[current_node, unvisited_nodes]\n    proximity = 1 / (dist_to_unvisited + 1e-9)\n    \n    entropy_list = []\n    for node in unvisited_nodes:\n        dist_to_others = distance_matrix[node, np.setdiff1d(unvisited_nodes, node)]\n        if len(dist_to_others) > 0:\n            prob = 1 / (dist_to_others + 1e-9)\n            prob = prob / prob.sum()\n            entropy = -np.sum(prob * np.log(prob + 1e-9))\n            entropy_list.append(entropy)\n        else:\n            entropy_list.append(0)\n    spatial_entropy = np.array(entropy_list)\n    \n    remaining_utility = np.mean(distance_matrix[np.ix_(unvisited_nodes, unvisited_nodes)], axis=1)\n    remaining_utility = (remaining_utility - remaining_utility.min()) / (remaining_utility.max() - remaining_utility.min() + 1e-9)\n    \n    dest_alignment = (distance_matrix[destination_node, unvisited_nodes] - distance_matrix[destination_node, unvisited_nodes].min()) / (distance_matrix[destination_node, unvisited_nodes].max() - distance_matrix[destination_node, unvisited_nodes].min() + 1e-9)\n    \n    progress = 1 - n_unvisited / distance_matrix.shape[0]\n    exploit_weight = 0.2 + 0.6 * progress\n    \n    scores = (exploit_weight * proximity +\n              (1 - exploit_weight) * (spatial_entropy - spatial_entropy.min()) / (spatial_entropy.max() - spatial_entropy.min() + 1e-9) +\n              0.3 * remaining_utility -\n              0.2 * dest_alignment)\n    \n    next_node_index = np.argmax(scores)\n    next_node = unvisited_nodes[next_node_index]\n    return next_node",
               "objective": 7.04665,
               "other_inf": [
                    "    entropy_list = []",
                    "    for node in unvisited_nodes:",
                    "            prob = 1 / (dist_to_others + 1e-9)",
                    "            prob = prob / prob.sum()",
                    "            entropy = -np.sum(prob * np.log(prob + 1e-9))",
                    "            entropy_list.append(entropy)",
                    "            entropy_list.append(0)",
                    "    spatial_entropy = np.array(entropy_list)",
                    "    progress = 1 - n_unvisited / distance_matrix.shape[0]",
                    "    exploit_weight = 0.2 + 0.6 * progress",
                    "    scores = (exploit_weight * proximity +",
                    "              (1 - exploit_weight) * (spatial_entropy - spatial_entropy.min()) / (spatial_entropy.max() - spatial_entropy.min() + 1e-9) +",
                    "              0.3 * remaining_utility -",
                    "              0.2 * dest_alignment)"
               ]
          },
          {
               "algorithm": "This algorithm selects the next node based on a weighted sum of normalized distance, local clustering centrality, and a destination-oriented penalization factor, dynamically adjusted by path progress and randomness.",
               "code": "import numpy as np\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if len(unvisited_nodes) == 1:\n        return unvisited_nodes[0]\n    \n    n_unvisited = len(unvisited_nodes)\n    n_total = distance_matrix.shape[0]\n    \n    dist_to_unvisited = distance_matrix[current_node, unvisited_nodes]\n    proximity = (dist_to_unvisited.max() - dist_to_unvisited) / (dist_to_unvisited.max() - dist_to_unvisited.min() + 1e-9)\n    \n    centrality_scores = []\n    for node in unvisited_nodes:\n        other_nodes = np.setdiff1d(unvisited_nodes, node)\n        if len(other_nodes) > 0:\n            local_distances = distance_matrix[node, other_nodes]\n            clustering = 1 / (local_distances.mean() + 1e-9)\n            centrality_scores.append(clustering)\n        else:\n            centrality_scores.append(0)\n    centrality_scores = np.array(centrality_scores)\n    if centrality_scores.max() > centrality_scores.min():\n        centrality_scores = (centrality_scores - centrality_scores.min()) / (centrality_scores.max() - centrality_scores.min())\n    \n    dest_penalty = distance_matrix[destination_node, unvisited_nodes] - distance_matrix[current_node, unvisited_nodes]\n    if dest_penalty.max() > dest_penalty.min():\n        dest_penalty = (dest_penalty - dest_penalty.min()) / (dest_penalty.max() - dest_penalty.min() + 1e-9)\n    \n    progress = 1 - n_unvisited / n_total\n    random_noise = np.random.random(len(unvisited_nodes)) * (1 - progress)\n    \n    exploit_weight = 0.3 + 0.5 * progress\n    balance_weight = 0.3 * (1 - progress)\n    \n    scores = (exploit_weight * proximity +\n              balance_weight * (1 - dest_penalty) +\n              0.2 * centrality_scores +\n              random_noise)\n    \n    next_node = unvisited_nodes[np.argmax(scores)]\n    return next_node",
               "objective": 13.62001,
               "other_inf": [
                    "    n_total = distance_matrix.shape[0]",
                    "    proximity = (dist_to_unvisited.max() - dist_to_unvisited) / (dist_to_unvisited.max() - dist_to_unvisited.min() + 1e-9)",
                    "    centrality_scores = []",
                    "        other_nodes = np.setdiff1d(unvisited_nodes, node)",
                    "        if len(other_nodes) > 0:",
                    "            local_distances = distance_matrix[node, other_nodes]",
                    "            clustering = 1 / (local_distances.mean() + 1e-9)",
                    "            centrality_scores.append(clustering)",
                    "            centrality_scores.append(0)",
                    "    centrality_scores = np.array(centrality_scores)",
                    "    if centrality_scores.max() > centrality_scores.min():",
                    "        centrality_scores = (centrality_scores - centrality_scores.min()) / (centrality_scores.max() - centrality_scores.min())",
                    "    dest_penalty = distance_matrix[destination_node, unvisited_nodes] - distance_matrix[current_node, unvisited_nodes]",
                    "    if dest_penalty.max() > dest_penalty.min():",
                    "        dest_penalty = (dest_penalty - dest_penalty.min()) / (dest_penalty.max() - dest_penalty.min() + 1e-9)",
                    "    progress = 1 - n_unvisited / n_total",
                    "    random_noise = np.random.random(len(unvisited_nodes)) * (1 - progress)",
                    "    exploit_weight = 0.3 + 0.5 * progress",
                    "    balance_weight = 0.3 * (1 - progress)",
                    "              balance_weight * (1 - dest_penalty) +",
                    "              0.2 * centrality_scores +",
                    "              random_noise)",
                    "    next_node = unvisited_nodes[np.argmax(scores)]"
               ]
          }
     ]
]